<!-- Main Layout Container with Sidebar Integration -->
<div
  class="flex h-screen overflow-hidden"
  data-user-authenticated="<%= user ? 'true' : 'false' %>"
>
  <!-- Hidden element to indicate this is a chat page -->
  <div id="current-page-indicator" data-page="chat" style="display: none"></div>
  <!-- Main Content Area with Sidebar -->
  <div
    class="flex-1 flex flex-col overflow-hidden min-w-0"
    style="min-width: 0; height: 100vh"
  >
    <!-- Ensure sidebar is visible -->
    <style>
      #sidebar {
        display: block !important;
        visibility: visible !important;
      }
      .nav-menu-visible {
        display: block !important;
        visibility: visible !important;
      }

      /* Ensure main chat content shows properly */
      #main-chat-content:not(.hidden) {
        display: flex !important;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
      }

      /* Messages container scrolling */
      #messages-container {
        flex: 1 1 0px;
        overflow-y: auto;
        min-height: 0;
      }

      /* Message input at bottom */
      #message-input-container {
        flex-shrink: 0;
        background: white;
        border-top: 1px solid #e5e7eb;
      }

      /* Typing indicator styling */
      #typing-indicator {
        background: white;
        border-top: 1px solid #e5e7eb;
        z-index: 10;
      }

      #typing-indicator:not(.hidden) {
        display: block !important;
        animation: fadeIn 0.3s ease-in-out;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      /* Hide conversations container when chat is active */
      #conversations-container.hidden {
        display: none !important;
      }

      /* Ensure proper scrolling in webkit browsers */
      #messages-container::-webkit-scrollbar {
        width: 6px;
      }

      #messages-container::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
      }

      #messages-container::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 3px;
      }

      #messages-container::-webkit-scrollbar-thumb:hover {
        background: #a8a8a8;
      }
    </style>

    <div class="flex-1 overflow-hidden">
      <!-- Conversations List -->
      <div id="conversations-container" class="bg-white rounded-xl shadow-md">
        <div class="p-6 border-b border-gray-200">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-semibold text-textMain">
                Active Conversations
              </h2>
              <p class="text-sm text-gray-900 mt-1">
                Your recent messages and support chats
              </p>
            </div>
            <button
              onclick="refreshConversations()"
              class="text-gray-500 hover:text-gray-700"
              title="Refresh conversations"
            >
              <i class="fas fa-sync-alt"></i>
            </button>
          </div>
        </div>

        <div id="conversations-list" class="divide-y divide-gray-200">
          <!-- Conversations will be loaded here -->
        </div>

        <div id="no-conversations" class="text-center py-12 hidden">
          <div
            class="w-24 h-24 bg-gray-100 rounded-full mx-auto mb-6 flex items-center justify-center"
          >
            <i class="fas fa-comments text-3xl text-gray-400"></i>
          </div>
          <h3 class="text-xl font-medium text-gray-900 mb-2">
            No Conversations Yet
          </h3>
          <p class="text-gray-500 mb-6">
            <% if (user.role === 'patient') { %> Start by finding a therapist or
            contacting admin support for any concerns. <% } else if (user.role
            === 'therapist') { %> Your patient conversations and admin support
            will appear here. <% } else { %> Start conversations with patients
            or therapists to provide support. <% } %>
          </p>
          <div class="space-y-3">
            <% if (user.role === 'patient') { %>
            <a href="/find-therapist" class="btn-primary inline-block">
              <i class="fas fa-search mr-2"></i>Find a Therapist
            </a>
            <button onclick="startAdminSupport()" class="btn-secondary ml-3">
              <i class="fas fa-headset mr-2"></i>Get Support
            </button>
            <% } else if (user.role === 'admin') { %>
            <button onclick="showPatientsModal()" class="btn-primary">
              <i class="fas fa-users mr-2"></i>Start Patient Chat
            </button>
            <% } %>
          </div>
        </div>

        <div id="loading-conversations" class="text-center py-8">
          <div
            class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-primary"
          ></div>
          <p class="text-gray-900 mt-2">Loading conversations...</p>
        </div>
      </div>

      <!-- Main Chat Content Area -->
      <div
        id="main-chat-content"
        class="hidden"
        style="display: none; height: 100%; flex-direction: column"
      >
        <!-- Therapist Header Info -->
        <div
          class="flex flex-wrap justify-between items-center gap-3 p-4 border-b border-gray-200 flex-shrink-0"
        >
          <div class="flex items-center gap-3 min-w-72">
            <!-- Profile Picture -->
            <div
              id="therapist-avatar"
              class="w-12 h-12 rounded-full bg-gray-300 flex items-center justify-center flex-shrink-0"
            >
              <i class="fas fa-user-md text-gray-600 text-lg"></i>
            </div>
            <div class="flex flex-col gap-3">
              <p
                class="text-[#111718] tracking-light text-[32px] font-bold leading-tight"
                id="therapist-name-header"
              >
                Therapist Name
              </p>
              <p
                class="text-[#618389] text-sm font-normal leading-normal"
                id="therapist-status"
              >
                Online now
              </p>
            </div>
          </div>

          <!-- Chat with Admin Button - Inline with header -->
          <div id="admin-chat-button" class="hidden">
            <button
              onclick="openAdminChat()"
              class="flex items-center gap-2 px-3 py-2 bg-white rounded-lg shadow-sm hover:shadow-md transition-all duration-200 border border-blue-200 hover:border-blue-300"
            >
              <div
                class="w-6 h-6 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center"
              >
                <i class="fas fa-headset text-white text-xs"></i>
              </div>
              <div class="text-left">
                <p class="text-xs font-semibold text-gray-900">
                  Chat with Admin
                </p>
              </div>
            </button>
          </div>
        </div>

        <!-- Video/Phone Call Buttons -->
        <div
          class="flex justify-between gap-2 px-4 py-3 border-b border-gray-200 flex-shrink-0"
        >
          <div class="flex gap-2">
            <!-- Test Typing Indicator Button (Development Only) -->
            <button
              onclick="startVideoCall()"
              class="p-2 text-[#111718] hover:bg-[#f0f4f4] rounded-lg transition-colors"
              title="Video Call"
            >
              <div
                class="text-[#111718]"
                data-icon="Video"
                data-size="24px"
                data-weight="regular"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24px"
                  height="24px"
                  fill="currentColor"
                  viewBox="0 0 256 256"
                >
                  <path
                    d="M164.44,105.34l-48-32A8,8,0,0,0,104,80v64a8,8,0,0,0,12.44,6.66l48-32a8,8,0,0,0,0-13.32ZM120,129.05V95l25.58,17ZM216,40H40A16,16,0,0,0,24,56V168a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,128H40V56H216V168Zm16,40a8,8,0,0,1-8,8H32a8,8,0,0,1,0-16H224A8,8,0,0,1,232,208Z"
                  ></path>
                </svg>
              </div>
            </button>
            <button
              onclick="startPhoneCall()"
              class="p-2 text-[#111718] hover:bg-[#f0f4f4] rounded-lg transition-colors"
              title="Phone Call"
            >
              <div
                class="text-[#111718]"
                data-icon="Phone"
                data-size="24px"
                data-weight="regular"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24px"
                  height="24px"
                  fill="currentColor"
                  viewBox="0 0 256 256"
                >
                  <path
                    d="M222.37,158.46l-47.11-21.11-.13-.06a16,16,0,0,0-15.17,1.4,8.12,8.12,0,0,0-.75.56L134.87,160c-15.42-7.49-31.34-23.29-38.83-38.51l20.78-24.71c.2-.25.39-.5.57-.77a16,16,0,0,0,1.32-15.06l0-.12L97.54,33.64a16,16,0,0,0-16.62-9.52A56.26,56.26,0,0,0,32,80c0,79.4,64.6,144,144,144a56.26,56.26,0,0,0,55.88-48.92A16,16,0,0,0,222.37,158.46ZM176,208A128.14,128.14,0,0,1,48,80,40.2,40.2,0,0,1,82.87,40a.61.61,0,0,0,0,.12l21,47L83.2,111.86a6.13,6.13,0,0,0-.57.77,16,16,0,0,0-1,15.7c9.06,18.53,27.73,37.06,46.46,46.11a16,16,0,0,0,15.75-1.14,8.44,8.44,0,0,0,.74-.56L168.89,152l47,21.05h0s.08,0,.11,0A40.21,40.21,0,0,1,176,208Z"
                  ></path>
                </svg>
              </div>
            </button>
          </div>
        </div>

        <!-- Messages Container - Scrollable Area -->
        <div
          id="messages-container"
          class="flex-1 overflow-y-auto p-4 space-y-4 min-h-0"
          style="flex: 1 1 0; overflow-y: auto"
        >
          <div class="text-center text-[#618389] py-8" id="chat-loading">
            <div
              class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-[#13c8ec] mr-2"
            ></div>
            <span>Loading messages...</span>
          </div>
        </div>

        <!-- Typing Indicator - Enhanced Version (moved outside messages container) -->
        <div id="typing-indicator" class="px-4 py-2 hidden" style="display: none; background: white; border-top: 1px solid #e5e7eb; position: relative; z-index: 10;">
          <div class="flex items-center gap-2">
            <div class="flex gap-1">
              <span class="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style="animation-delay: 0ms"></span>
              <span class="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style="animation-delay: 150ms"></span>
              <span class="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style="animation-delay: 300ms"></span>
            </div>
            <span class="text-sm text-gray-600"><span id="typing-user-name"></span> is typing...</span>
          </div>
        </div>

        <!-- Message Input Area - Fixed at Bottom -->
        <div
          id="message-input-container"
          class="flex items-center px-4 py-3 gap-3 border-t border-gray-200 flex-shrink-0"
          style="background: white; border-top: 1px solid #e5e7eb"
        >
          <div class="flex flex-col min-w-40 h-12 flex-1">
            <div class="flex w-full flex-1 items-stretch rounded-xl h-full">
              <input
                type="text"
                id="message-input"
                placeholder="Type a message..."
                class="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-xl text-[#111718] focus:outline-0 focus:ring-0 border-none bg-[#f0f4f4] focus:border-none h-full placeholder:text-[#618389] px-4 rounded-r-none border-r-0 pr-2 text-base font-normal leading-normal"
              />
              <div
                class="flex border-none bg-[#f0f4f4] items-center justify-center pr-2 rounded-r-xl border-l-0"
              >
                <div class="flex items-center gap-4 justify-end">
                  <div class="flex items-center gap-1">
                    <button
                      type="button"
                      class="flex items-center justify-center p-1.5 text-[#618389] hover:text-[#111718] transition-colors"
                      title="Add emoji"
                    >
                      <div
                        class="text-[#618389]"
                        data-icon="Smiley"
                        data-size="20px"
                        data-weight="regular"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="20px"
                          height="20px"
                          fill="currentColor"
                          viewBox="0 0 256 256"
                        >
                          <path
                            d="M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216ZM80,108a12,12,0,1,1,12,12A12,12,0,0,1,80,108Zm96,0a12,12,0,1,1-12-12A12,12,0,0,1,176,108Zm-1.07,48c-10.29,17.79-27.4,28-46.93,28s-36.63-10.2-46.92-28a8,8,0,1,1,13.84-8c7.47,12.91,19.21,20,33.08,20s25.61-7.1,33.07-20a8,8,0,0,1,13.86,8Z"
                          ></path>
                        </svg>
                      </div>
                    </button>
                    <button
                      type="button"
                      class="flex items-center justify-center p-1.5 text-[#618389] hover:text-[#111718] transition-colors"
                      title="Attach file"
                    >
                      <div
                        class="text-[#618389]"
                        data-icon="Paperclip"
                        data-size="20px"
                        data-weight="regular"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="20px"
                          height="20px"
                          fill="currentColor"
                          viewBox="0 0 256 256"
                        >
                          <path
                            d="M209.66,122.34a8,8,0,0,1,0,11.32l-82.05,82a56,56,0,0,1-79.2-79.21L147.67,35.73a40,40,0,1,1,56.61,56.55L105,193A24,24,0,1,1,71,159L154.3,74.38A8,8,0,1,1,165.7,85.6L82.39,170.31a8,8,0,1,0,11.27,11.36L192.93,81A24,24,0,1,0,159,47L59.76,147.68a40,40,0,1,0,56.53,56.62l82.06-82A8,8,0,0,1,209.66,122.34Z"
                          ></path>
                        </svg>
                      </div>
                    </button>
                  </div>
                  <button
                    type="submit"
                    id="send-btn"
                    class="min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-xl h-8 px-4 bg-[#13c8ec] text-white text-sm font-medium leading-normal"
                  >
                    <span class="truncate">Send</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Chat View - Simple Design -->
      <div id="chat-view" class="hidden">
        <!-- Back Button -->
        <div
          class="flex justify-between gap-2 px-4 py-3 border-b border-gray-200"
        >
          <button
            onclick="backToConversations()"
            class="p-2 text-[#111718] hover:bg-[#f0f4f4] rounded-lg transition-colors"
          >
            <div
              class="text-[#111718]"
              data-icon="ArrowLeft"
              data-size="20px"
              data-weight="regular"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20px"
                height="20px"
                fill="currentColor"
                viewBox="0 0 256 256"
              >
                <path
                  d="M224,128a8,8,0,0,1-8,8H120v64a8,8,0,0,1-13.66,5.66l-72-72a8,8,0,0,1,0-11.32l72-72A8,8,0,0,1,120,56v64h96A8,8,0,0,1,224,128Z"
                ></path>
              </svg>
            </div>
          </button>
        </div>
      </div>

      <!-- Admin Support Modal for Patients -->
      <div
        id="admin-support-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg max-w-2xl w-full mx-4">
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">Get Admin Support</h3>
              <button
                onclick="closeAdminSupportModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div class="p-6">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
              <div class="flex items-start">
                <i class="fas fa-info-circle text-blue-600 mr-3 mt-1"></i>
                <div>
                  <h4 class="font-medium text-blue-800 mb-1">
                    How can we help you?
                  </h4>
                  <p class="text-blue-700 text-sm">
                    Our admin team is here to assist with technical issues,
                    account problems, therapist concerns, or any questions about
                    the platform.
                  </p>
                </div>
              </div>
            </div>

            <form id="admin-support-form" onsubmit="submitAdminSupport(event)">
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-900 mb-2"
                  >What do you need help with?</label
                >
                <select
                  id="support-type"
                  name="supportType"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  required
                >
                  <option value="">Select issue type</option>
                  <option value="technical">Technical Issue</option>
                  <option value="therapist">Therapist Related</option>
                  <option value="billing">Billing Question</option>
                  <option value="account">Account Problem</option>
                  <option value="platform">Platform Question</option>
                  <option value="other">Other</option>
                </select>
              </div>

              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >Describe your issue</label
                >
                <textarea
                  id="support-message"
                  name="message"
                  rows="4"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  placeholder="Please provide details about your concern or question..."
                  required
                ></textarea>
              </div>

              <div class="flex justify-end space-x-3">
                <button
                  type="button"
                  onclick="closeAdminSupportModal()"
                  class="px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  <i class="fas fa-paper-plane mr-2"></i>Send Message
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>

      <!-- Therapist-Admin Chat Modal (Enhanced Interface) -->
      <div
        id="therapist-admin-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg max-w-2xl w-full mx-4">
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <div>
                <h3 class="text-lg font-semibold">Contact Admin Team</h3>
                <p class="text-sm text-gray-900 mt-1">
                  Start a conversation with our admin support team
                </p>
              </div>
              <button
                onclick="closeTherapistAdminModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div class="p-6">
            <div
              class="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-4 mb-4"
            >
              <div class="flex items-start">
                <div
                  class="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center mr-3"
                >
                  <i class="fas fa-headset text-white text-lg"></i>
                </div>
                <div>
                  <h4 class="font-medium text-blue-800 mb-1">
                    Admin Support Team
                  </h4>
                  <p class="text-blue-700 text-sm">
                    Our admin team is here to help with any questions, concerns,
                    or issues you may have. This will open a private chat just
                    like your patient conversations.
                  </p>
                </div>
              </div>
            </div>

            <form
              id="therapist-admin-form"
              onsubmit="submitTherapistAdminMessage(event)"
            >
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >What would you like to discuss?</label
                >
                <textarea
                  id="therapist-admin-message"
                  name="message"
                  rows="4"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  placeholder="Describe what you need help with, or just say 'Hello' to start the conversation..."
                  required
                ></textarea>
              </div>

              <div class="bg-gray-50 rounded-lg p-3 mb-4">
                <div class="flex items-start">
                  <i class="fas fa-info-circle text-gray-500 mr-2 mt-0.5"></i>
                  <div class="text-sm text-gray-600">
                    <p class="font-medium mb-1">What happens next?</p>
                    <p>
                      After sending this message, you'll be taken to a full chat
                      interface where you can have a normal conversation with
                      the admin team, just like chatting with your patients.
                    </p>
                  </div>
                </div>
              </div>

              <div class="flex justify-end space-x-3">
                <button
                  type="button"
                  onclick="closeTherapistAdminModal()"
                  class="px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  class="px-4 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg hover:from-blue-700 hover:to-purple-700"
                >
                  <i class="fas fa-comments mr-2"></i>Start Chat
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>

      <!-- Patient Concern Modal (Admin Only) -->
      <div
        id="patient-concern-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg max-w-2xl w-full mx-4">
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">Submit Patient Concern</h3>
              <button
                onclick="closePatientConcernModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <form
            id="patient-concern-form"
            onsubmit="submitPatientConcern(event)"
            class="p-6"
          >
            <input type="hidden" id="concern-patient-id" name="patientId" />
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >Concern Type</label
                >
                <select
                  id="concern-type"
                  name="concernType"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  required
                >
                  <option value="">Select type</option>
                  <option value="technical">Technical Issue</option>
                  <option value="therapist">Therapist Related</option>
                  <option value="platform">Platform Issue</option>
                  <option value="billing">Billing Issue</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >Severity</label
                >
                <select
                  id="concern-severity"
                  name="severity"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  required
                >
                  <option value="">Select severity</option>
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                  <option value="critical">Critical</option>
                </select>
              </div>
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Title</label
              >
              <input
                type="text"
                id="concern-title"
                name="title"
                class="w-full border border-gray-300 rounded-lg px-4 py-2"
                placeholder="Brief description of the concern"
                required
              />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Description</label
              >
              <textarea
                id="concern-description"
                name="description"
                rows="4"
                class="w-full border border-gray-300 rounded-lg px-4 py-2"
                placeholder="Detailed description of the concern"
                required
              ></textarea>
            </div>
            <div class="flex justify-end space-x-3">
              <button
                type="button"
                onclick="closePatientConcernModal()"
                class="px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50"
              >
                Cancel
              </button>
              <button
                type="submit"
                class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
              >
                Submit Concern
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- Therapist Contract Modal (Admin Only) -->
      <div
        id="therapist-contract-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg max-w-2xl w-full mx-4">
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">Send Contract to Therapist</h3>
              <button
                onclick="closeTherapistContractModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <form
            id="therapist-contract-form"
            onsubmit="submitTherapistContract(event)"
            class="p-6"
          >
            <input
              type="hidden"
              id="contract-therapist-id"
              name="therapistId"
            />
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >Contract Type</label
                >
                <select
                  id="contract-type"
                  name="contractType"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                  required
                >
                  <option value="">Select type</option>
                  <option value="terms_update">Terms Update</option>
                  <option value="policy_change">Policy Change</option>
                  <option value="guidelines">Guidelines</option>
                  <option value="requirements">Requirements</option>
                  <option value="other">Other</option>
                </select>
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2"
                  >Acknowledgment Required</label
                >
                <select
                  id="requires-acknowledgment"
                  name="requiresAcknowledgment"
                  class="w-full border border-gray-300 rounded-lg px-4 py-2"
                >
                  <option value="true">Yes</option>
                  <option value="false">No</option>
                </select>
              </div>
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Title</label
              >
              <input
                type="text"
                id="contract-title"
                name="title"
                class="w-full border border-gray-300 rounded-lg px-4 py-2"
                placeholder="Contract title"
                required
              />
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Content</label
              >
              <textarea
                id="contract-content"
                name="content"
                rows="6"
                class="w-full border border-gray-300 rounded-lg px-4 py-2"
                placeholder="Contract content and details"
                required
              ></textarea>
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Acknowledgment Deadline (Optional)</label
              >
              <input
                type="datetime-local"
                id="acknowledgment-deadline"
                name="acknowledgmentDeadline"
                class="w-full border border-gray-300 rounded-lg px-4 py-2"
              />
            </div>
            <div class="flex justify-end space-x-3">
              <button
                type="button"
                onclick="closeTherapistContractModal()"
                class="px-4 py-2 text-gray-900 border border-gray-300 rounded-lg hover:bg-gray-50"
              >
                Cancel
              </button>
              <button
                type="submit"
                class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Send Contract
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- Patients Modal (Admin Only) -->
      <div
        id="patients-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div
          class="bg-white rounded-lg max-w-4xl w-full mx-4 max-h-96 overflow-y-auto"
        >
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">Select Patient to Chat With</h3>
              <button
                onclick="closePatientsModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div id="patients-list" class="p-6">
            <div class="text-center text-gray-500">
              <i class="fas fa-spinner fa-spin mb-2"></i>
              <p class="text-gray-900">Loading patients...</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Therapists Modal (Admin Only) -->
      <div
        id="therapists-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div
          class="bg-white rounded-lg max-w-4xl w-full mx-4 max-h-96 overflow-y-auto"
        >
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">
                Select Therapist to Chat With
              </h3>
              <button
                onclick="closeTherapistsModal()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div id="therapists-list" class="p-6">
            <div class="text-center text-gray-500">
              <i class="fas fa-spinner fa-spin mb-2"></i>
              <p class="text-gray-900">Loading therapists...</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Incoming Call Modal -->
      <div
        id="incoming-call-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50"
        style="display: none !important;"
      >
        <div class="bg-white rounded-lg max-w-md w-full mx-4">
          <div class="p-6 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <h3 class="text-lg font-semibold">Incoming Call</h3>
              <button
                onclick="declineCall()"
                class="text-gray-500 hover:text-gray-700"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div class="p-6 text-center">
            <div class="mb-4">
              <div id="incoming-call-avatar" class="w-20 h-20 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center mx-auto mb-4">
                <i class="fas fa-user text-white text-2xl"></i>
              </div>
              <h4 class="text-xl font-semibold mb-2" id="incoming-caller-name">Unknown Caller</h4>
              <p class="text-gray-600 mb-2" id="incoming-call-type">Video Call</p>
              <p class="text-sm text-gray-500">Calling...</p>
            </div>
            <div class="flex justify-center space-x-4">
              <button
                onclick="declineCall()"
                class="flex items-center justify-center w-12 h-12 bg-red-500 hover:bg-red-600 text-white rounded-full transition-colors"
              >
                <i class="fas fa-phone-slash text-lg"></i>
              </button>
              <button
                onclick="answerCall()"
                class="flex items-center justify-center w-12 h-12 bg-green-500 hover:bg-green-600 text-white rounded-full transition-colors"
              >
                <i class="fas fa-phone text-lg"></i>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Toast Notification -->
      <div
        id="toast-notification"
        class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden transform transition-all duration-300"
      >
        <div class="flex items-center">
          <i class="fas fa-check-circle mr-2"></i>
          <span id="toast-message">Action completed successfully!</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Socket.IO Client -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Enhanced Chat JavaScript with Admin Support -->
  <script>
    // Global variables
    let conversations = [];
    let currentConversationId = null;
    let messages = [];
    let otherUser = {};
    let socket = null;
    let isPageVisible = true;
    let messagePollingInterval = null;
    let conversationPollingInterval = null;
    let lastMessageCount = 0;
    let typingTimer = null;
    let currentUserId = "<%= user.id %>";
    let userRole = "<%= user.role %>";

    // Initialize on page load
    document.addEventListener("DOMContentLoaded", function () {
      console.log("Initializing enhanced chat with admin support");

      // Show test button in development
      const testBtn = document.getElementById("test-typing-btn");
      if (testBtn && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
        testBtn.style.display = "block";
      }

      // Ensure clean state on page load
      resetCallState();

      // Initialize Socket.IO
      initializeSocket();

      // Load conversations
      loadConversations();

      // Set up event listeners
      setupEventListeners();

      // Handle direct conversation loading from URL
      const conversationId =
        '<%= typeof conversationId !== "undefined" ? conversationId || "" : "" %>';
      if (conversationId && conversationId.trim() !== "") {
        console.log("=== DIRECT CONVERSATION LOAD ===");
        console.log("Conversation ID:", conversationId);

        currentConversationId = conversationId;

        // Hide conversations list
        const conversationsContainer = document.getElementById(
          "conversations-container"
        );
        if (conversationsContainer) {
          conversationsContainer.classList.add("hidden");
          console.log("conversations-container hidden");
        }

        // Show main chat content
        const mainChatContent = document.getElementById("main-chat-content");
        if (mainChatContent) {
          mainChatContent.classList.remove("hidden");
          mainChatContent.style.display = "block";
          console.log("main-chat-content shown");
        }

        // Hide chat-view (back button view)
        const chatView = document.getElementById("chat-view");
        if (chatView) {
          chatView.classList.add("hidden");
          console.log("chat-view hidden");
        }

        // Load chat data
        loadChat(conversationId);

        // Show message input for direct conversation access
        const messageInputContainer = document.getElementById(
          "message-input-container"
        );
        if (messageInputContainer) {
          messageInputContainer.style.display = "flex";
          console.log("Message input shown for direct conversation");
        }

        // Update avatar for direct conversation access - only if otherUser exists and has data
        if (typeof otherUser !== "undefined" && otherUser && otherUser.name) {
          updateTherapistAvatar(otherUser);
          console.log("Avatar updated for direct conversation");
        } else {
          console.log("‚ö†Ô∏è otherUser not ready for direct conversation avatar update");
        }

        // Show/hide admin button for direct conversation access
        const adminButton = document.getElementById("admin-chat-button");
        if (adminButton) {
          // Show admin button for therapist conversations, hide for admin conversations
          const isAdminConversation = conv?.conversation_type === "admin";
          const shouldShowAdminButton = !isAdminConversation;
          if (shouldShowAdminButton) {
            adminButton.classList.remove("hidden");
            console.log("Admin button shown for direct therapist conversation");
          } else {
            adminButton.classList.add("hidden");
            console.log("Admin button hidden for direct admin conversation");
          }
        } else {
          console.log("Admin button not found in DOM for direct conversation");
        }

        // Join socket room for real-time updates
        setTimeout(() => {
          if (socket && socket.connected) {
            socket.emit("join_conversation", conversationId);
            console.log("Joined socket room:", conversationId);
          }
        }, 500);
      }
    });

    // Initialize Socket.IO connection
    function initializeSocket() {
      console.log("Initializing Socket.IO connection...");
      socket = io();

      socket.on("connect", () => {
        console.log("Socket connected:", socket.id);
        updateConnectionStatus(true);

        // Authenticate socket connection
        socket.emit("authenticate", { userId: currentUserId, role: userRole });

        // ‚úÖ SETUP WEBRTC HANDLERS HERE - AFTER SOCKET IS CONNECTED
        setupWebRTCHandlers();
      });

      socket.on("disconnect", () => {
        console.log("Socket disconnected");
        updateConnectionStatus(false);

        // Reset WebRTC handlers flag so they can be re-established on reconnect
        window.webRTCHandlersSetup = false;
      });

      socket.on("connect_error", (error) => {
        console.error("Socket connection error:", error);
        updateConnectionStatus(false);
      });

      socket.on("new_message", (data) => {
        // Only log in development
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log("New message received via socket:", data);
          console.log("Current conversation ID:", currentConversationId);
        }

        if (
          data &&
          data.conversationId === currentConversationId &&
          data.message &&
          data.message.content
        ) {
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log("Message is for current conversation, processing...");
          }

          // Enhanced duplicate detection to avoid duplicates
          const messageExists = messages.some(
            (msg) => msg.id === data.message.id
          );

          // Additional check: if message exists and was sent by current user very recently, ignore it
          const isRecentOwnMessage = messages.some(
            (msg) =>
              msg.id === data.message.id &&
              msg.sender_id === currentUserId &&
              data.message.created_at &&
              msg.created_at &&
              Math.abs(
                new Date(data.message.created_at) - new Date(msg.created_at)
              ) < 5000 // 5 seconds
          );

          if (!messageExists || !isRecentOwnMessage) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log("Adding new message to array");
            }
            messages.push(data.message);
            displayMessages();

            // Scroll to bottom to show new message
            const container = document.getElementById("messages-container");
            if (container) {
              setTimeout(() => {
                container.scrollTop = container.scrollHeight;
              }, 100);
            }
          }
        } else if (data && data.conversationId !== currentConversationId) {
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log("Message for different conversation, updating list");
          }
          // Update conversation list for unread count
          loadConversations();
        } else {
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log("Invalid socket message data:", data);
          }
        }
      });

      socket.on("user_typing", (data) => {
        console.log("üì® Typing event received:", data);
        console.log("üîç Current conversation ID:", currentConversationId);
        console.log("üë§ Current user ID:", currentUserId);
        console.log("üìä Event data:", {
          conversationId: data.conversationId,
          userId: data.userId,
          userName: data.userName,
          matchesConversation: data.conversationId === currentConversationId,
          notCurrentUser: data.userId !== currentUserId
        });

        if (data.conversationId === currentConversationId && data.userId !== currentUserId) {
          console.log("‚úÖ Conditions met, showing typing indicator");
          // Show typing indicator with the other user's name
          const typingUserName = otherUser ? otherUser.name : (data.userName || "Someone");
          console.log("üë§ Showing typing for:", typingUserName);
          showTypingIndicator(typingUserName);
        } else {
          console.log("‚ùå Conditions not met:", {
            conversationMatch: data.conversationId === currentConversationId,
            notCurrentUser: data.userId !== currentUserId
          });
        }
      });

      socket.on("user_stopped_typing", (data) => {
        console.log("üîá Stopped typing event received:", data);
        console.log("üîç Current conversation ID:", currentConversationId);
        if (data.conversationId === currentConversationId) {
          console.log("‚úÖ Hiding typing indicator");
          hideTypingIndicator();
        } else {
          console.log("‚ùå Stop typing event for different conversation");
        }
      });
    }

    // ‚úÖ NEW FUNCTION: Setup WebRTC handlers AFTER socket is ready
    function setupWebRTCHandlers() {
      console.log("üìû Setting up WebRTC socket handlers...");

      if (!socket) {
        console.error("‚ùå Socket not available for WebRTC handlers");
        return;
      }

      // Ensure we don't set up handlers multiple times
      if (window.webRTCHandlersSetup) {
        console.log("‚ö†Ô∏è WebRTC handlers already set up, skipping...");
        return;
      }
      window.webRTCHandlersSetup = true;

      // Handle incoming call notification
      socket.on('incoming_call', (data) => {
        console.log('üì≤ Incoming call event received:', data);
        console.log('üîç Current conversation ID:', currentConversationId);
        console.log('üìû Call conversation ID:', data.conversationId);

        if (data && data.conversationId === currentConversationId) {
          console.log('‚úÖ Call is for current conversation, showing modal');

          // Store complete call data including callType
          incomingCallData = {
            conversationId: data.conversationId,
            callType: data.callType,
            fromUser: data.fromUser,
            fromUserId: data.fromUserId
          };
          console.log('üíæ Stored incoming call data:', incomingCallData);

          // Show modal immediately
          setTimeout(() => {
            showIncomingCallModal(data);
          }, 100);
        } else {
          console.log('‚ö†Ô∏è Call is for different conversation:', data.conversationId, 'vs', currentConversationId);
        }
      });

      // Handle WebRTC offer
      socket.on('webrtc_offer', async (data) => {
        console.log('üì• Received WebRTC offer:', data);
        if (data && data.conversationId === currentConversationId) {
          // Store the complete offer data including callType IMMEDIATELY
          window.pendingOffer = {
            offer: data.offer,
            callType: data.callType,
            conversationId: data.conversationId
          };
          console.log('üíæ Offer stored immediately in window.pendingOffer:', window.pendingOffer);

          // If we're not the initiator and have a peer connection, process immediately
          if (!isInitiator && peerConnection) {
            try {
              console.log('üîß Processing WebRTC offer immediately...');

              await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
              console.log('‚úÖ Remote description set');

              const answer = await peerConnection.createAnswer();
              await peerConnection.setLocalDescription(answer);
              console.log('‚úÖ Answer created and local description set');

              if (socket && socket.connected) {
                socket.emit('webrtc_answer', {
                  conversationId: currentConversationId,
                  answer: answer
                });
                console.log('‚úÖ Answer sent to caller');
              }

              // Clear pending offer since we processed it
              window.pendingOffer = null;
            } catch (error) {
              console.error('‚ùå Error handling WebRTC offer:', error);
              showToast('Failed to process call offer', 'error');
            }
          } else {
            console.log('‚ö†Ô∏è Peer connection not ready yet, offer stored for later processing');
            console.log('üìã Current state:', {
              isInitiator,
              hasPeerConnection: !!peerConnection,
              pendingOffer: !!window.pendingOffer
            });
          }
        } else {
          console.log('‚ö†Ô∏è Offer for different conversation:', data?.conversationId, 'vs', currentConversationId);
        }
      });

      // Handle WebRTC answer
      socket.on('webrtc_answer', async (data) => {
        console.log('üì• Received WebRTC answer:', data);
        if (data && data.conversationId === currentConversationId && isInitiator && peerConnection && data.answer) {
          try {
            console.log('üîß Setting remote description from answer...');
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            console.log('‚úÖ Answer processed successfully');

            // Update call status
            const statusEl = document.getElementById('call-status');
            if (statusEl) {
              statusEl.textContent = 'Connected';
            }

            // Process any pending ICE candidates that arrived before the answer
            if (window.pendingIceCandidates && window.pendingIceCandidates.length > 0) {
              console.log(`üì° Processing ${window.pendingIceCandidates.length} pending ICE candidates`);
              for (const candidate of window.pendingIceCandidates) {
                try {
                  await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                  console.log('‚úÖ Added pending ICE candidate');
                } catch (e) {
                  console.error('‚ùå Error adding pending ICE candidate:', e);
                }
              }
              window.pendingIceCandidates = [];
            }

            showToast('‚úÖ Call connected successfully!');
          } catch (error) {
            console.error('‚ùå Error handling WebRTC answer:', error);
            showToast('Failed to connect call', 'error');
          }
        } else {
          console.log('‚ö†Ô∏è Answer conditions not met:', {
            hasData: !!data,
            conversationMatch: data?.conversationId === currentConversationId,
            isInitiator,
            hasPeerConnection: !!peerConnection,
            hasAnswer: !!data?.answer
          });
        }
      });

      // Handle ICE candidates
      socket.on('webrtc_ice_candidate', async (data) => {
        console.log('üì• Received ICE candidate:', data);
        if (data && data.conversationId === currentConversationId && data.candidate) {
          if (peerConnection && peerConnection.remoteDescription) {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
              console.log('‚úÖ ICE candidate added');
            } catch (error) {
              console.error('‚ùå Error adding ICE candidate:', error);
            }
          } else {
            // Store ICE candidate for later if peer connection isn't ready
            console.log('üíæ Storing ICE candidate for later');
            if (!window.pendingIceCandidates) {
              window.pendingIceCandidates = [];
            }
            window.pendingIceCandidates.push(data.candidate);
          }
        }
      });

      // Handle call ended
      socket.on('call_ended', (data) => {
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log('üìû Call ended by remote user:', data);
        }
        if (data && data.conversationId === currentConversationId && isCallActive) {
          console.log('üõë Ending call due to remote user action');
          endCall();
          showToast('Call ended by other user');
        } else {
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('‚ö†Ô∏è Ignoring call_ended event - not active or wrong conversation');
          }
        }
      });

      console.log("‚úÖ WebRTC socket handlers setup complete");
    }

    // Reset call state to ensure clean startup
    function resetCallState() {
      console.log('üîÑ Resetting call state on page load...');
      isCallActive = false;
      currentCall = null;
      isInitiator = false;
      incomingCallData = null;
      window.pendingOffer = null;
      if (window.pendingIceCandidates) {
        window.pendingIceCandidates = [];
      }
      window.webRTCHandlersSetup = false;

      // Hide any existing modals
      hideIncomingCallModal();

      // Remove any existing call modals
      const existingModal = document.getElementById('call-modal');
      if (existingModal) {
        existingModal.remove();
      }

      console.log('‚úÖ Call state reset completed');
    }

    // Set up event listeners
    function setupEventListeners() {
      // Message input handling
      const messageInput = document.getElementById("message-input");
      const sendBtn = document.getElementById("send-btn");

      if (messageInput) {
        // Typing detection
        messageInput.addEventListener("input", handleTyping);

        // Enter key to send message
        messageInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage(e);
          }
        });

        console.log("Message input listener attached");
      } else {
        console.error("Message input not found!");
      }

      if (sendBtn) {
        // Send button click
        sendBtn.addEventListener("click", sendMessage);
        console.log("Send button listener attached");
      }

      // Page visibility change
      document.addEventListener("visibilitychange", () => {
        isPageVisible = !document.hidden;
      });
    }

    // Update connection status indicator
    function updateConnectionStatus(connected) {
      const indicator = document.getElementById("status-indicator");
      const text = document.getElementById("status-text");

      if (indicator && text) {
        if (connected) {
          indicator.className = "w-2 h-2 rounded-full bg-green-400 mr-2";
          text.textContent = "Connected";
        } else {
          indicator.className = "w-2 h-2 rounded-full bg-red-400 mr-2";
          text.textContent = "Disconnected";
        }
      }
    }

    // Load conversations from server
    async function loadConversations() {
      const loadingElement = document.getElementById("loading-conversations");
      const conversationsList = document.getElementById("conversations-list");
      const noConversations = document.getElementById("no-conversations");

      if (loadingElement) loadingElement.classList.remove("hidden");

      try {
        // Use appropriate endpoint based on user role
        let endpoint;
        if (userRole === "admin") {
          endpoint = "/admin/chat/conversations";
        } else if (userRole === "therapist") {
          endpoint = "/therapist/api/conversations";
        } else {
          endpoint = "/appointments/chat/conversations";
        }

        console.log("Loading conversations from endpoint:", endpoint);
        const response = await fetch(endpoint, {
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
        });
        const data = await response.json();

        if (data.success) {
          conversations = data.conversations || [];
          console.log("Loaded conversations:", conversations.length);
          displayConversations();
        } else {
          console.error("Failed to load conversations:", data.error);
          showNoConversations();
        }
      } catch (error) {
        console.error("Error loading conversations:", error);
        showNoConversations();
      } finally {
        if (loadingElement) loadingElement.classList.add("hidden");
      }
    }

    // Display conversations list with admin conversation indicators
    function displayConversations() {
      const container = document.getElementById("conversations-list");
      const noConversations = document.getElementById("no-conversations");

      if (!conversations || conversations.length === 0) {
        container.innerHTML = "";
        noConversations.classList.remove("hidden");
        return;
      }

      noConversations.classList.add("hidden");

      container.innerHTML = conversations
        .map((conversation) => {
          const isAdmin = userRole === "admin";
          const isAdminConversation =
            conversation.conversation_type === "admin";

          // Determine other user based on conversation type and current user role
          let otherUser;
          if (isAdminConversation) {
            if (userRole === "admin") {
              // Admin viewing patient's admin support request
              otherUser = {
                name: conversation.patient_name || "Patient",
                image: conversation.patient_image,
                role: "patient",
                specialty: "Patient Support",
              };
            } else {
              // Patient/Therapist viewing admin support conversation
              otherUser = {
                name: "Admin Support",
                image: null,
                role: "admin",
                specialty: "CalmTunes Admin Team",
              };
            }
          } else {
            // Regular patient-therapist conversation
            if (userRole === "patient") {
              // Patient viewing - show therapist info
              otherUser = {
                name: conversation.therapist_name || "Therapist",
                image: conversation.therapist_image,
                role: "therapist",
                specialty: conversation.specialty || "General Practice",
              };
            } else {
              // Therapist viewing - show patient info
              otherUser = {
                name: conversation.patient_name || "Patient",
                image: conversation.patient_image,
                role: "patient",
                specialty: "Patient",
              };
            }
          }

          const imageUrl =
            otherUser.image && !otherUser.image.startsWith("http")
              ? `/uploads/${otherUser.image}`
              : otherUser.image;

          const lastMessageTime = conversation.last_message_time
            ? formatMessageTime(conversation.last_message_time)
            : formatMessageTime(conversation.created_at);

          const unreadCount = parseInt(conversation.unread_count) || 0;

          // Admin conversation badge
          const adminBadge = isAdminConversation
            ? '<span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full ml-2"><i class="fas fa-headset mr-1"></i>Support</span>'
            : "";

          return `
      <div class="p-6 hover:bg-gray-50 cursor-pointer transition-colors border-l-4 ${
        isAdminConversation
          ? "border-blue-500 bg-blue-50/30"
          : "border-transparent"
      }"
           onclick="openConversation('${conversation.id}')">
        <div class="flex items-center justify-between">
          <div class="flex items-center flex-1">
            ${
              imageUrl
                ? `<img src="${imageUrl}" alt="${otherUser.name}" class="w-12 h-12 rounded-full object-cover mr-4">`
                : `<div class="w-12 h-12 bg-gradient-to-br ${
                    isAdminConversation
                      ? "from-blue-500 to-purple-600"
                      : "from-blue-400 to-purple-500"
                  } rounded-full flex items-center justify-center mr-4">
                ${
                  isAdminConversation
                    ? '<i class="fas fa-headset text-white"></i>'
                    : `<span class="text-white font-semibold">${otherUser.name
                        .charAt(0)
                        .toUpperCase()}</span>`
                }
              </div>`
            }
            <div class="flex-1 min-w-0">
              <div class="flex items-center justify-between">
                <div class="flex items-center">
                  <h3 class="font-semibold text-textMain truncate">${escapeHtml(
                    otherUser.name
                  )}</h3>
                  ${adminBadge}
                </div>
                <div class="flex items-center space-x-2 ml-2">
                  ${
                    unreadCount > 0
                      ? `<span class="bg-red-500 text-white text-xs rounded-full px-2 py-1 min-w-[20px] text-center">
                      ${unreadCount > 99 ? "99+" : unreadCount}
                    </span>`
                      : ""
                  }
                  <span class="text-sm text-gray-500">${lastMessageTime}</span>
                </div>
              </div>
              ${
                otherUser.specialty
                  ? `<p class="text-sm ${
                      isAdminConversation ? "text-blue-600" : "text-gray-500"
                    } mb-1">${escapeHtml(otherUser.specialty)}</p>`
                  : ""
              }
              <p class="text-gray-600 truncate">
                ${conversation.last_message || "No messages yet"}
              </p>
            </div>
          </div>
          <div class="ml-4">
            <i class="fas fa-chevron-right text-gray-400"></i>
          </div>
        </div>
      </div>
    `;
        })
        .join("");
    }

    // Rest of the JavaScript functions would continue here...
    // Including loadChat, sendMessage, displayMessages, etc.

    // Utility functions
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function formatMessageTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diff = now - date;

      if (diff < 24 * 60 * 60 * 1000) {
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      if (diff < 7 * 24 * 60 * 60 * 1000) {
        return date.toLocaleDateString([], { weekday: "short" });
      }

      return date.toLocaleDateString([], { month: "short", day: "numeric" });
    }

    function showToast(message) {
      const toast = document.getElementById("toast-notification");
      const messageEl = document.getElementById("toast-message");

      messageEl.textContent = message;
      toast.classList.remove("hidden");

      setTimeout(() => {
        toast.classList.add("hidden");
      }, 3000);
    }

    // Update therapist avatar/profile picture
    function updateTherapistAvatar(otherUser) {
      const avatarContainer = document.getElementById("therapist-avatar");
      if (!avatarContainer) {
        console.error("‚ùå Avatar container not found");
        return;
      }

      if (!otherUser) {
        console.error("‚ùå No otherUser provided");
        return;
      }

      // Only log avatar updates in development mode
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log("üîç Updating avatar - otherUser:", otherUser.name);
      }

      // Build the image URL properly
      let imageUrl = null;

      if (otherUser.image && otherUser.image.trim() !== "" && otherUser.image !== "null") {
        // Handle different image path formats
        if (otherUser.image.startsWith("http")) {
          imageUrl = otherUser.image;
        } else if (otherUser.image.startsWith("/uploads")) {
          imageUrl = otherUser.image;
        } else if (otherUser.image.startsWith("uploads/")) {
          imageUrl = "/" + otherUser.image;
        } else {
          // For therapist images, use /uploads/profiles/ path since that's where the file actually exists
          imageUrl = `/uploads/profiles/${otherUser.image}`;
        }

        console.log("‚úÖ Using profile image URL:", imageUrl);
      } else {
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log("‚ö†Ô∏è No valid image found, using letter avatar");
        }
      }

      // Get first letter for fallback
      const firstLetter = otherUser.name ? otherUser.name.charAt(0).toUpperCase() : "U";

      // Determine background color based on role
      let bgColor = "bg-gray-500"; // Default
      if (otherUser.role === "admin") {
        bgColor = "bg-gradient-to-br from-blue-500 to-purple-600";
      } else if (otherUser.role === "therapist") {
        bgColor = "bg-blue-500";
      } else if (otherUser.role === "patient") {
        bgColor = "bg-green-500";
      }

      if (imageUrl) {
        // Create image with error handling
        avatarContainer.innerHTML = `
          <img
            src="${imageUrl}"
            alt="${otherUser.name}"
            class="w-12 h-12 rounded-full object-cover border-2 border-gray-200"
            onerror="console.error('‚ùå Image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<div class=\\'w-12 h-12 ${bgColor} rounded-full flex items-center justify-center\\'><span class=\\'text-white font-semibold text-lg\\'>${firstLetter}</span></div>'"
          >
        `;
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log("‚úÖ Avatar set to image successfully");
        }
      } else {
        // Use letter avatar
        avatarContainer.innerHTML = `
          <div class="w-12 h-12 ${bgColor} rounded-full flex items-center justify-center">
            <span class="text-white font-semibold text-lg">${firstLetter}</span>
          </div>
        `;
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log("‚ÑπÔ∏è Avatar set to letter:", firstLetter);
        }
      }
    }

    // Update top buttons visibility based on conversation type
    function updateTopButtons(isAdminConversation) {
      const adminButton = document.getElementById("admin-chat-button");
      const therapistsButton = document.getElementById("therapists-button");

      if (isAdminConversation) {
        // Hide admin button, show therapists button
        if (adminButton) adminButton.classList.add("hidden");
        if (therapistsButton) therapistsButton.classList.remove("hidden");
      } else {
        // Show admin button, hide therapists button
        if (adminButton) adminButton.classList.remove("hidden");
        if (therapistsButton) therapistsButton.classList.add("hidden");
      }

      console.log("Top buttons updated:", {
        isAdminConversation,
        adminButton: !!adminButton,
        therapistsButton: !!therapistsButton,
      });
    }

    // Admin Support Functions for Patients
    function startAdminSupport() {
      document.getElementById("admin-support-modal").classList.remove("hidden");
      document.getElementById("admin-support-modal").classList.add("flex");
    }

    function closeAdminSupportModal() {
      document.getElementById("admin-support-modal").classList.add("hidden");
      document.getElementById("admin-support-modal").classList.remove("flex");
    }

    async function submitAdminSupport(event) {
      event.preventDefault();

      const form = event.target;
      const formData = new FormData(form);

      const supportData = {
        participantId: currentUserId,
        participantType: "patient",
        message: `Support Request (${formData.get(
          "supportType"
        )}): ${formData.get("message")}`,
      };

      try {
        const response = await fetch("/support/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(supportData),
        });

        const data = await response.json();

        if (data.success) {
          closeAdminSupportModal();
          showToast("Support request sent! Admin will respond soon.");

          // Refresh conversations to show new admin chat
          setTimeout(() => {
            loadConversations();
          }, 1000);

          // Optionally redirect to the conversation
          if (data.conversationId) {
            setTimeout(() => {
              openConversation(data.conversationId);
            }, 2000);
          }
        } else {
          showToast(data.error || "Failed to send support request", "error");
        }
      } catch (error) {
        console.error("Error submitting admin support:", error);
        showToast("Failed to send support request", "error");
      }
    }

    // Open Admin Chat Function
    async function openAdminChat() {
      try {
        // Check if user is authenticated
        const isAuthenticated =
          document.querySelector("[data-user-authenticated]")?.dataset
            .userAuthenticated === "true";

        if (!isAuthenticated) {
          alert("Please login to chat with admin.");
          window.location.href = "/login";
          return;
        }

        console.log("Opening admin chat...");

        // Use the support endpoint to start admin conversation
        const response = await fetch("/support/start", {
          method: "POST",
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            message: "Hello, I need help with my account.",
          }),
        });

        console.log("Admin chat response status:", response.status);

        if (!response.ok) {
          if (response.status === 401) {
            console.error("Authentication failed - redirecting to login");
            alert("Your session has expired. Please login again.");
            window.location.href = "/login";
            return;
          }
          const errorText = await response.text();
          throw new Error(
            `HTTP error! status: ${response.status}, message: ${errorText}`
          );
        }

        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const errorText = await response.text();
          throw new Error(`Server returned HTML instead of JSON: ${errorText}`);
        }

        const data = await response.json();
        console.log("Admin chat response data:", data);

        if (data.success) {
          console.log(
            "Admin chat started successfully, redirecting to:",
            data.conversationId
          );
          // Redirect to the chat page with the new conversation ID
          window.location.href = `/chat/${data.conversationId}`;
        } else {
          alert(data.error || "Failed to start admin chat");
        }
      } catch (error) {
        console.error("Error starting admin chat:", error);
        alert(
          "Failed to start admin chat. Please try again. Error: " +
            error.message
        );
      }
    }

    // Contact Admin Function for Therapists (Enhanced)
    function contactAdmin() {
      document
        .getElementById("therapist-admin-modal")
        .classList.remove("hidden");
      document.getElementById("therapist-admin-modal").classList.add("flex");
      document.getElementById("therapist-admin-message").focus();
    }

    function closeTherapistAdminModal() {
      document.getElementById("therapist-admin-modal").classList.add("hidden");
      document.getElementById("therapist-admin-modal").classList.remove("flex");
      document.getElementById("therapist-admin-form").reset();
    }

    async function submitTherapistAdminMessage(event) {
      event.preventDefault();

      const form = event.target;
      const formData = new FormData(form);
      const message = formData.get("message").trim();

      if (!message) {
        showToast("Please enter a message", "error");
        return;
      }

      try {
        // Use the support endpoint instead of admin endpoint
        const response = await fetch("/support/start", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: message }),
        });

        if (!response.ok) {
          const text = await response.text();
          console.error("Response not OK:", response.status, text);
          throw new Error(`Failed to start chat (${response.status})`);
        }

        const data = await response.json();

        if (data.success) {
          closeTherapistAdminModal();
          showToast("Chat started with admin team!");

          // Refresh conversations
          await loadConversations();

          // Open the conversation after a delay
          if (data.conversationId) {
            setTimeout(() => {
              openConversation(data.conversationId);
            }, 1000);
          }
        } else {
          showToast(data.error || "Failed to start admin chat", "error");
        }
      } catch (error) {
        console.error("Error starting admin chat:", error);
        showToast("Failed to start admin chat: " + error.message, "error");
      }
    }

    // Admin Functions for Patient Concerns
    function showPatientConcernModal() {
      if (!otherUser || otherUser.role !== "patient") {
        showToast(
          "This feature is only available when chatting with patients",
          "error"
        );
        return;
      }

      document.getElementById("concern-patient-id").value = otherUser.id;
      document
        .getElementById("patient-concern-modal")
        .classList.remove("hidden");
      document.getElementById("patient-concern-modal").classList.add("flex");
    }

    function closePatientConcernModal() {
      document.getElementById("patient-concern-modal").classList.add("hidden");
      document.getElementById("patient-concern-modal").classList.remove("flex");
    }

    async function submitPatientConcern(event) {
      event.preventDefault();

      const form = event.target;
      const formData = new FormData(form);

      const concernData = {
        patientId: formData.get("patientId"),
        concernType: formData.get("concernType"),
        severity: formData.get("severity"),
        title: formData.get("title"),
        description: formData.get("description"),
      };

      try {
        const response = await fetch("/admin/submit-patient-concern", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(concernData),
        });

        const data = await response.json();

        if (data.success) {
          closePatientConcernModal();
          showToast("Patient concern submitted successfully");
          form.reset();
        } else {
          showToast(data.error || "Failed to submit concern", "error");
        }
      } catch (error) {
        console.error("Error submitting patient concern:", error);
        showToast("Failed to submit concern", "error");
      }
    }

    // Admin Functions for Therapist Contracts
    function showTherapistContractModal() {
      if (!otherUser || otherUser.role !== "therapist") {
        showToast(
          "This feature is only available when chatting with therapists",
          "error"
        );
        return;
      }

      document.getElementById("contract-therapist-id").value = otherUser.id;
      document
        .getElementById("therapist-contract-modal")
        .classList.remove("hidden");
      document.getElementById("therapist-contract-modal").classList.add("flex");
    }

    function closeTherapistContractModal() {
      document
        .getElementById("therapist-contract-modal")
        .classList.add("hidden");
      document
        .getElementById("therapist-contract-modal")
        .classList.remove("flex");
    }

    async function submitTherapistContract(event) {
      event.preventDefault();

      const form = event.target;
      const formData = new FormData(form);

      const contractData = {
        therapistId: formData.get("therapistId"),
        contractType: formData.get("contractType"),
        title: formData.get("title"),
        content: formData.get("content"),
        requiresAcknowledgment:
          formData.get("requiresAcknowledgment") === "true",
        acknowledgmentDeadline: formData.get("acknowledgmentDeadline") || null,
      };

      try {
        const response = await fetch("/admin/send-therapist-contract", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(contractData),
        });

        const data = await response.json();

        if (data.success) {
          closeTherapistContractModal();
          showToast("Contract sent to therapist successfully");
          form.reset();
        } else {
          showToast(data.error || "Failed to send contract", "error");
        }
      } catch (error) {
        console.error("Error sending therapist contract:", error);
        showToast("Failed to send contract", "error");
      }
    }

    // Admin Modals for Patient/Therapist Selection
    async function showPatientsModal() {
      document.getElementById("patients-modal").classList.remove("hidden");
      document.getElementById("patients-modal").classList.add("flex");

      try {
        const response = await fetch("/admin/chat/patients", {
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
        });
        const data = await response.json();

        if (data.success) {
          displayPatientsList(data.patients || []);
        } else {
          showToast("Failed to load patients", "error");
        }
      } catch (error) {
        console.error("Error loading patients:", error);
        showToast("Error loading patients", "error");
      }
    }

    function closePatientsModal() {
      document.getElementById("patients-modal").classList.add("hidden");
      document.getElementById("patients-modal").classList.remove("flex");
    }

    function displayPatientsList(patients) {
      const container = document.getElementById("patients-list");

      if (patients.length === 0) {
        container.innerHTML = `
      <div class="text-center text-gray-500 py-8">
        <i class="fas fa-users text-4xl mb-2"></i>
        <p>No patients found</p>
      </div>
    `;
        return;
      }

      container.innerHTML = patients
        .map(
          (patient) => `
    <div class="patient-item p-4 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer mb-3"
         onclick="startChatWithPatient('${patient.id}', '${escapeHtml(
            patient.name
          )}')">
      <div class="flex items-center">
        <div class="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mr-4">
          ${
            patient.profile_image
              ? `<img src="/uploads/${patient.profile_image}" alt="${patient.name}" class="w-12 h-12 rounded-full object-cover">`
              : '<i class="fas fa-user text-green-600"></i>'
          }
        </div>
        <div class="flex-1">
          <h4 class="font-medium text-gray-900">${escapeHtml(patient.name)}</h4>
          <p class="text-sm text-gray-600">${escapeHtml(patient.email)}</p>
          <div class="flex items-center mt-1 text-xs text-gray-500">
            <span>Joined: ${new Date(
              patient.created_at
            ).toLocaleDateString()}</span>
            ${
              patient.appointment_count > 0
                ? `<span class="ml-3">${patient.appointment_count} appointments</span>`
                : ""
            }
          </div>
        </div>
      </div>
    </div>
  `
        )
        .join("");
    }

    async function showTherapistsModal() {
      document.getElementById("therapists-modal").classList.remove("hidden");
      document.getElementById("therapists-modal").classList.add("flex");

      try {
        const response = await fetch("/admin/chat/therapists", {
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
        });
        const data = await response.json();

        if (data.success) {
          displayTherapistsList(data.therapists || []);
        } else {
          showToast("Failed to load therapists", "error");
        }
      } catch (error) {
        console.error("Error loading therapists:", error);
        showToast("Error loading therapists", "error");
      }
    }

    function closeTherapistsModal() {
      document.getElementById("therapists-modal").classList.add("hidden");
      document.getElementById("therapists-modal").classList.remove("flex");
    }

    function displayTherapistsList(therapists) {
      const container = document.getElementById("therapists-list");

      if (therapists.length === 0) {
        container.innerHTML = `
      <div class="text-center text-gray-500 py-8">
        <i class="fas fa-user-md text-4xl mb-2"></i>
        <p>No therapists found</p>
      </div>
    `;
        return;
      }

      container.innerHTML = therapists
        .map(
          (therapist) => `
    <div class="therapist-item p-4 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer mb-3"
         onclick="startChatWithTherapist('${therapist.id}', '${escapeHtml(
            therapist.name
          )}')">
      <div class="flex items-center">
        <div class="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mr-4">
          ${
            therapist.profile_image
              ? `<img src="/uploads/${therapist.profile_image}" alt="${therapist.name}" class="w-12 h-12 rounded-full object-cover">`
              : '<i class="fas fa-user-md text-blue-600"></i>'
          }
        </div>
        <div class="flex-1">
          <h4 class="font-medium text-gray-900">${escapeHtml(
            therapist.name
          )}</h4>
          <p class="text-sm text-blue-600">${escapeHtml(
            therapist.specialty || "General Practice"
          )}</p>
          <p class="text-sm text-gray-600">${escapeHtml(therapist.email)}</p>
          <div class="flex items-center mt-1 text-xs text-gray-500">
            <span>Joined: ${new Date(
              therapist.created_at
            ).toLocaleDateString()}</span>
            ${
              therapist.patient_count > 0
                ? `<span class="ml-3">${therapist.patient_count} patients</span>`
                : ""
            }
          </div>
        </div>
      </div>
    </div>
  `
        )
        .join("");
    }

    // Start Chat Functions
    async function startChatWithPatient(patientId, patientName) {
      closePatientsModal();

      try {
        const response = await fetch("/admin/chat/start", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            participantId: patientId,
            participantType: "patient",
            message: `Hello ${patientName}, this is ${
              userRole === "admin" ? "Admin" : "Support"
            } from CalmTunes. How can I help you today?`,
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
          showToast("Chat started with patient");
          loadConversations();

          if (data.conversationId) {
            setTimeout(() => {
              openConversation(data.conversationId);
            }, 1000);
          }
        } else {
          showToast(data.error || "Failed to start chat", "error");
        }
      } catch (error) {
        console.error("Error starting chat with patient:", error);
        showToast("Failed to start chat", "error");
      }
    }

    async function startChatWithTherapist(therapistId, therapistName) {
      closeTherapistsModal();

      try {
        const response = await fetch("/admin/chat/start", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            participantId: therapistId,
            participantType: "therapist",
            message: `Hello ${therapistName}, this is ${
              userRole === "admin" ? "Admin" : "Support"
            } from CalmTunes. I wanted to check in with you. How are things going?`,
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
          showToast("Chat started with therapist");
          loadConversations();

          if (data.conversationId) {
            setTimeout(() => {
              openConversation(data.conversationId);
            }, 1000);
          }
        } else {
          showToast(data.error || "Failed to start chat", "error");
        }
      } catch (error) {
        console.error("Error starting chat with therapist:", error);
        showToast("Failed to start chat", "error");
      }
    }

    function openConversation(conversationId) {
      currentConversationId = conversationId;
      console.log("‚úÖ Opening conversation:", conversationId);

      // CRITICAL: Join socket room immediately
      if (socket && socket.connected) {
        socket.emit("join_conversation", conversationId);
        console.log("‚úÖ Joined socket room:", conversationId);
      } else {
        console.error("‚ùå Socket not connected when trying to join room");
      }

      // Show main chat content and hide conversations list
      document.getElementById("conversations-container").classList.add("hidden");
      document.getElementById("main-chat-content").classList.remove("hidden");
      document.getElementById("chat-view").classList.add("hidden");

      // Load chat data
      loadChat(conversationId);

      // Start polling for new messages as fallback
      startMessagePolling(conversationId);
    }

    function startMessagePolling(conversationId) {
      // Clear existing polling
      if (messagePollingInterval) {
        clearInterval(messagePollingInterval);
      }

      // Poll every 5 seconds for new messages
      messagePollingInterval = setInterval(async () => {
        if (currentConversationId && isPageVisible) {
          try {
            // Use appropriate endpoint based on user role
            let endpoint;
            if (userRole === "therapist") {
              endpoint = `/therapist/api/conversations/${conversationId}/messages`;
            } else {
              endpoint = `/appointments/chat/${conversationId}/messages`;
            }

            const response = await fetch(endpoint, {
              credentials: "same-origin",
              headers: {
                "Content-Type": "application/json",
              },
            });

            if (response.ok) {
              const data = await response.json();
              if (data.success && data.messages) {
                const newMessages = data.messages.filter(
                  (msg) => !messages.some((existing) => existing.id === msg.id)
                );

                if (newMessages.length > 0) {
                  console.log(
                    "Found new messages via polling:",
                    newMessages.length
                  );
                  messages.push(...newMessages);
                  displayMessages();

                  // Scroll to bottom
                  const container =
                    document.getElementById("messages-container");
                  if (container) {
                    setTimeout(() => {
                      container.scrollTop = container.scrollHeight;
                    }, 100);
                  }
                }
              }
            }
          } catch (error) {
            console.error("Error polling for messages:", error);
          }
        }
      }, 5000);
    }

    async function loadChat(conversationId) {
      console.log("Loading chat for conversation:", conversationId);
      const loadingElement = document.getElementById("chat-loading");
      if (loadingElement) loadingElement.style.display = "block";

      try {
        // Use appropriate endpoint based on user role
        let endpoint;
        if (userRole === "therapist") {
          endpoint = `/therapist/api/conversations/${conversationId}/messages`;
        } else {
          endpoint = `/appointments/chat/${conversationId}/messages`;
        }

        console.log("Fetching from endpoint:", endpoint);

        const response = await fetch(endpoint, {
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
        });

        console.log("Response status:", response.status);
        const responseText = await response.text();
        console.log("Response text:", responseText);

        if (!response.ok) {
          // Try fallback endpoint if therapist endpoint fails
          if (userRole === "therapist" && response.status === 404) {
            console.log("Therapist endpoint failed, trying appointments endpoint");
            endpoint = `/appointments/chat/${conversationId}/messages`;
            const fallbackResponse = await fetch(endpoint, {
              credentials: "same-origin",
              headers: {
                "Content-Type": "application/json",
              },
            });

            if (!fallbackResponse.ok) {
              throw new Error(`HTTP error! status: ${response.status}, message: ${responseText}`);
            }

            const data = await fallbackResponse.json();
            console.log("Chat data received from fallback:", data);
          } else {
            throw new Error(`HTTP error! status: ${response.status}, message: ${responseText}`);
          }
        }

        const data = JSON.parse(responseText);
        console.log("Chat data received:", data);

        if (data.success) {
          messages = data.messages || [];
          lastMessageCount = messages.length;
          console.log("Loaded messages:", messages.length);
          console.log("Messages array:", messages);

          const conv = data.conversation;
          console.log("Conversation data:", conv);

          // FIXED: Use otherUser data directly from backend response
          if (conv && conv.other_user) {
            // Backend already provides the correct otherUser object
            otherUser = conv.other_user;
            console.log("Using otherUser from backend:", otherUser);
          } else {
            // Fallback: construct otherUser manually (shouldn't happen with fixed backend)
            const isAdminConversation = conv?.conversation_type === "admin";

            if (isAdminConversation) {
              if (userRole === "admin") {
                otherUser = {
                  id: conv.participant_id,
                  name: conv.participant_name || "User",
                  role: conv.participant_role || "user",
                  image: conv.participant_image,
                  specialty: conv.participant_role === "therapist" ? "Therapist" : "Patient",
                };
              } else {
                otherUser = {
                  id: conv.admin_id || "admin",
                  name: "Admin Support",
                  role: "admin",
                  image: null,
                  specialty: "CalmTunes Admin",
                };
              }
            } else {
              // Regular patient-therapist conversation
              if (userRole === "therapist") {
                otherUser = {
                  id: conv.patient_id,
                  name: conv.patient_name || "Patient",
                  role: "patient",
                  image: conv.patient_image,
                  specialty: "Patient",
                };
              } else {
                otherUser = {
                  id: conv.therapist_id,
                  name: conv.therapist_name || "Therapist",
                  role: "therapist",
                  image: conv.therapist_image,
                  specialty: conv.specialty || "General Practice",
                };
              }
            }
            console.log("Constructed otherUser manually:", otherUser);
          }

          console.log("Final otherUser:", otherUser);

          // Update therapist name and status in header
          const therapistNameHeader = document.getElementById("therapist-name-header");
          const therapistStatus = document.getElementById("therapist-status");
          const isAdminConversation = conv?.conversation_type === "admin";

          if (therapistNameHeader) {
            if (isAdminConversation) {
              therapistNameHeader.textContent = "Admin Support";
              console.log("Header set to: Admin Support");
            } else if (userRole === "therapist") {
              // Therapist viewing - show patient name (no Dr. prefix)
              therapistNameHeader.textContent = otherUser.name || "Patient";
              console.log("THERAPIST viewing - Header set to:", otherUser.name);
            } else if (userRole === "patient") {
              // Patient viewing - show therapist name with Dr. prefix
              let therapistName = otherUser.name && otherUser.name !== "Therapist"
                ? otherUser.name
                : "Therapist";

              // Add Dr. prefix if not already present
              if (!therapistName.toLowerCase().startsWith("dr.") &&
                  !therapistName.toLowerCase().startsWith("doctor")) {
                therapistName = "Dr. " + therapistName;
              }

              therapistNameHeader.textContent = therapistName;
              console.log("PATIENT viewing - Header set to:", therapistName);
            } else {
              therapistNameHeader.textContent = otherUser.name || "Unknown User";
              console.log("Header set to:", otherUser.name);
            }
          }

          // Update profile picture - ONLY AFTER otherUser is properly set
          if (otherUser && otherUser.name) {
            console.log("üîÑ Updating avatar with otherUser:", otherUser);
            console.log("üìã Full otherUser object:", JSON.stringify(otherUser, null, 2));
            updateTherapistAvatar(otherUser);
          } else {
            console.error("‚ùå otherUser not properly set, cannot update avatar");
          }

          if (therapistStatus) {
            if (isAdminConversation) {
              therapistStatus.textContent = "Admin Support";
              console.log("Status set to: Admin Support (admin conversation)");
            } else {
              therapistStatus.textContent = "Online now";
              console.log("Status set to: Online now (therapist conversation)");
            }
          }

          console.log("Final conversation setup:", {
            isAdminConversation,
            otherUser: otherUser.name,
            otherUserRole: otherUser.role,
            otherUserImage: otherUser.image,
            headerName: therapistNameHeader?.textContent,
            headerStatus: therapistStatus?.textContent
          });

          // Update top buttons
          updateTopButtons(isAdminConversation);

          // Show/hide admin button
          const adminButton = document.getElementById("admin-chat-button");
          if (adminButton) {
            if (!isAdminConversation) {
              adminButton.classList.remove("hidden");
              console.log("Admin button shown for therapist conversation");
            } else {
              adminButton.classList.add("hidden");
              console.log("Admin button hidden for admin conversation");
            }
          }

          // Show message input
          const messageInputContainer = document.getElementById("message-input-container");
          if (messageInputContainer) {
            messageInputContainer.style.display = "flex";
            console.log("Message input container shown");
          }

          displayMessages();
        } else {
          console.error("Failed to load chat:", data.error);
          if (loadingElement) {
            loadingElement.innerHTML = `<p class="text-red-500">Failed to load messages: ${data.error}</p>`;
          }
        }
      } catch (error) {
        console.error("Error loading chat:", error);
        if (loadingElement) {
          loadingElement.innerHTML = `<p class="text-red-500">Error loading messages: ${error.message}</p>`;
        }
      } finally {
        if (loadingElement) loadingElement.style.display = "none";
      }
    }

    function displayChatHeader() {
      const header = document.getElementById("chat-header");
      if (!header) return;

      const isAdminConversation =
        otherUser.role === "admin" || otherUser.specialty === "CalmTunes Admin";

      let imageHtml = "";
      if (otherUser.image) {
        const imageUrl = otherUser.image.startsWith("/")
          ? otherUser.image
          : `/uploads/${otherUser.image}`;
        imageHtml = `<img src="${imageUrl}" alt="${otherUser.name}" class="w-10 h-10 rounded-full object-cover mr-3">`;
      } else {
        const bgClass = isAdminConversation
          ? "from-blue-500 to-purple-600"
          : "from-blue-400 to-purple-500";
        const iconClass = isAdminConversation ? "fas fa-headset" : "";

        imageHtml = `<div class="w-10 h-10 bg-gradient-to-br ${bgClass} rounded-full flex items-center justify-center mr-3">
      ${
        isAdminConversation
          ? `<i class="${iconClass} text-white text-sm"></i>`
          : `<span class="text-white font-semibold text-sm">${otherUser.name
              .charAt(0)
              .toUpperCase()}</span>`
      }
    </div>`;
      }

      // Create the header content based on the design
      let headerContent = "";

      if (isAdminConversation) {
        headerContent = `
        ${imageHtml}
        <div>
          <h3 class="font-semibold text-textMain text-lg">${escapeHtml(
            otherUser.name
          )}</h3>
          <p class="text-xs text-blue-600 font-medium">Admin Support</p>
        </div>
      `;
      } else {
        // Regular therapist/patient conversation - show name prominently like in the image
        headerContent = `
        <div class="flex items-center">
          ${imageHtml}
          <div>
            <h3 class="font-semibold text-textMain text-lg">${escapeHtml(
              otherUser.name
            )}</h3>
            <div class="flex items-center gap-2">
              <div class="w-2 h-2 bg-green-500 rounded-full"></div>
              <p class="text-sm text-gray-600">Online now</p>
            </div>
          </div>
        </div>
      `;
      }

      header.innerHTML = headerContent;
    }

    function displayMessages() {
      const container = document.getElementById("messages-container");
      if (!container) {
        console.error("Messages container not found");
        return;
      }

      // Only log in development
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log("Displaying messages:", messages.length);
      }

      // Hide loading indicator
      const loadingElement = document.getElementById("chat-loading");
      if (loadingElement) {
        loadingElement.style.display = "none";
      }

      if (messages.length === 0) {
        container.innerHTML = `
          <div class="text-center text-gray-500 py-8">
            <i class="fas fa-comments text-4xl mb-2 text-gray-400"></i>
            <p class="text-gray-500">No messages yet. Start the conversation!</p>
          </div>
        `;
        container.classList.remove("hidden");
        return;
      }

      const messagesHtml = messages
        .map((msg) => {
          if (!msg || !msg.content) {
            return "";
          }

          const isOwn = msg.sender_id == currentUserId;

          // FIXED: Get avatar URL from the message data itself
          let avatarUrl = "";

          if (isOwn) {
            // Own message - use current user's profile image from session
            const userProfileImage = "<%= user.profile_image || '' %>";
            if (userProfileImage && userProfileImage.trim() !== "" && userProfileImage !== "null") {
              if (userProfileImage.startsWith("http")) {
                avatarUrl = userProfileImage;
              } else if (userProfileImage.startsWith("/uploads")) {
                avatarUrl = userProfileImage;
              } else if (userProfileImage.startsWith("uploads/")) {
                avatarUrl = "/" + userProfileImage;
              } else {
                avatarUrl = "/uploads/profiles/" + userProfileImage;
              }
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log("Own message - Using profile image:", avatarUrl);
              }
            }
          } else {
            // FIXED: Other user message - use the new simplified image fields
            let imageFilename = null;
 
            if (msg.sender_therapist_profile_image && msg.sender_therapist_profile_image.trim() !== "" && msg.sender_therapist_profile_image !== "null") {
              imageFilename = msg.sender_therapist_profile_image;
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log("Other user message - Using therapist profile image:", imageFilename);
              }
            } else if (msg.sender_user_profile_image && msg.sender_user_profile_image.trim() !== "" && msg.sender_user_profile_image !== "null") {
              imageFilename = msg.sender_user_profile_image;
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log("Other user message - Using user profile image:", imageFilename);
              }
            } else {
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log("Other user message - No profile image found, using fallback");
              }
            }
 
            if (imageFilename) {
              if (imageFilename.startsWith("http")) {
                avatarUrl = imageFilename;
              } else if (imageFilename.startsWith("/uploads/profiles/")) {
                // Already a complete path - use as is
                avatarUrl = imageFilename;
              } else if (imageFilename.startsWith("/uploads")) {
                avatarUrl = imageFilename;
              } else if (imageFilename.startsWith("uploads/")) {
                avatarUrl = "/" + imageFilename;
              } else {
                // Just a filename - add the profiles path
                avatarUrl = "/uploads/profiles/" + imageFilename;
              }
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log("Other user message - Final avatar URL:", avatarUrl);
              }
            }
          }

          // Get sender name
          const senderName = isOwn
            ? "<%= user.name %>"
            : (msg.sender_name || otherUser.name || "User");
          const firstLetter = senderName.charAt(0).toUpperCase();

          // Create avatar HTML
          let avatarHtml = "";
          if (avatarUrl) {
            avatarHtml = `
              <div
                class="bg-center bg-no-repeat aspect-square bg-cover rounded-full w-10 shrink-0"
                style="background-image: url('${avatarUrl}');"
                onerror="this.style.backgroundImage=''; this.innerHTML='<div class=\\'w-10 h-10 ${isOwn ? 'bg-blue-500' : 'bg-gray-500'} rounded-full flex items-center justify-center\\'><span class=\\'text-white font-semibold\\'>${firstLetter}</span></div>'"
              ></div>
            `;
          } else {
            // Fallback to letter avatar with role-based colors
            const bgColor = isOwn
              ? "bg-blue-500"
              : (msg.sender_role === "therapist" ? "bg-blue-500" : "bg-green-500");

            avatarHtml = `
              <div class="w-10 h-10 ${bgColor} rounded-full flex items-center justify-center">
                <span class="text-white font-semibold">${firstLetter}</span>
              </div>
            `;
          }

          const messageBubbleClass = isOwn
            ? "bg-[#13c8ec] text-white"
            : "bg-[#f0f4f4] text-[#111718]";

          return `
            <div class="flex items-end gap-3 ${isOwn ? "justify-end" : "justify-start"} mb-4">
              ${!isOwn ? avatarHtml : ""}
              <div class="flex flex-1 flex-col gap-1 items-${isOwn ? "end" : "start"}">
                <p class="text-[#618389] text-[13px] font-normal leading-normal max-w-[360px] ${isOwn ? "text-right" : ""}">
                  ${isOwn ? "You" : escapeHtml(senderName)}
                </p>
                <div class="text-base font-normal leading-normal flex max-w-[360px] rounded-xl px-4 py-3 ${messageBubbleClass}">
                  ${escapeHtml(msg.content)}
                </div>
              </div>
              ${isOwn ? avatarHtml : ""}
            </div>
          `;
        })
        .join("");

      container.innerHTML = messagesHtml;
      container.classList.remove("hidden");

      // Scroll to bottom
      setTimeout(() => {
        container.scrollTop = container.scrollHeight;
        console.log("Scrolled to bottom, height:", container.scrollHeight);
      }, 100);

      container.style.overflowY = "auto";
    }

    async function sendMessage(event) {
      if (event) {
        event.preventDefault();
      }

      const input = document.getElementById("message-input");
      const sendBtn = document.getElementById("send-btn");
      const content = input.value.trim();

      if (!content) return;

      if (!currentConversationId) {
        showToast("No conversation selected", "error");
        return;
      }

      console.log("Sending message:", {
        conversationId: currentConversationId,
        content: content.substring(0, 50),
      });

      // Disable input while sending
      input.disabled = true;
      sendBtn.disabled = true;
      sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

      try {
        // Use appropriate endpoint based on user role
        let endpoint;
        if (userRole === "therapist") {
          endpoint = `/therapist/api/conversations/${currentConversationId}/messages`;
        } else {
          endpoint = `/appointments/chat/${currentConversationId}/send`;
        }

        const response = await fetch(endpoint, {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content }),
        });

        console.log("Send response status:", response.status);

        if (!response.ok) {
          const errorText = await response.text();
          console.error("Send failed:", response.status, errorText);
          throw new Error(`Failed to send message (${response.status})`);
        }

        const data = await response.json();
        console.log("Send response data:", data);

        if (data.success) {
          // Add message locally for immediate feedback
          const newMessage = {
            id: data.message.id,
            conversation_id: currentConversationId,
            sender_id: currentUserId,
            content: content,
            created_at: data.message.created_at || new Date().toISOString(),
            sender_role: userRole,
            sender_name: "<%= user.name %>",
          };

          messages.push(newMessage);
          displayMessages();

          // Emit via socket for real-time updates
          if (socket && socket.connected) {
            socket.emit("new_message", {
              conversationId: currentConversationId,
              message: newMessage,
            });
          }

          input.value = "";
          console.log("Message sent successfully");
        } else {
          console.error("Failed to send message:", data.error);
          showToast(data.error || "Failed to send message", "error");
        }
      } catch (error) {
        console.error("Error sending message:", error);
        showToast("Failed to send message: " + error.message, "error");
      } finally {
        // Re-enable input
        input.disabled = false;
        sendBtn.disabled = false;
        sendBtn.innerHTML = '<span class="truncate">Send</span>';
      }
    }

    function backToConversations() {
      currentConversationId = null;

      // Stop message polling
      if (messagePollingInterval) {
        clearInterval(messagePollingInterval);
        messagePollingInterval = null;
      }

      // Leave socket room
      if (socket) {
        socket.emit("leave_conversation", currentConversationId);
      }

      // Hide main chat content and show conversations
      document.getElementById("main-chat-content").classList.add("hidden");
      document.getElementById("chat-view").classList.add("hidden");
      document
        .getElementById("conversations-container")
        .classList.remove("hidden");

      // Refresh conversations
      loadConversations();
    }

    async function closeConversation() {
      if (!currentConversationId) return;

      const reason = prompt("Reason for closing conversation (optional):");

      try {
        // Use appropriate endpoint based on user role and conversation type
        let endpoint;
        if (userRole === "admin") {
          endpoint = `/admin/close-conversation/${currentConversationId}`;
        } else {
          // Patients and therapists use the same endpoint
          endpoint = `/appointments/chat/${currentConversationId}/close`;
        }

        const response = await fetch(endpoint, {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            reason: reason || "Conversation closed",
          }),
        });

        const data = await response.json();

        if (data.success) {
          showToast("Conversation closed successfully");
          backToConversations();
        } else {
          showToast(data.error || "Failed to close conversation", "error");
        }
      } catch (error) {
        console.error("Error closing conversation:", error);
        showToast("Failed to close conversation", "error");
      }
    }

    function refreshConversations() {
      loadConversations();
      showToast("Conversations refreshed");
    }

    function refreshMessages() {
      if (currentConversationId) {
        console.log(
          "Manually refreshing messages for conversation:",
          currentConversationId
        );
        loadChat(currentConversationId);
        showToast("Messages refreshed");
      } else {
        showToast("No conversation selected", "error");
      }
    }

    function showNoConversations() {
      const container = document.getElementById("conversations-list");
      const noConversations = document.getElementById("no-conversations");

      container.innerHTML = "";
      noConversations.classList.remove("hidden");
    }

    function handleTyping() {
      if (socket && currentConversationId && socket.connected) {
        // Emit typing event
        socket.emit("typing", {
          conversationId: currentConversationId,
          userId: currentUserId,
          userName: "<%= user.name %>",
        });

        // Clear existing timer
        clearTimeout(typingTimer);

        // Set new timer to emit stop typing after 1 second
        typingTimer = setTimeout(() => {
          socket.emit("stop_typing", {
            conversationId: currentConversationId,
            userId: currentUserId,
          });
        }, 1000);
      }
    }

    function showTypingIndicator(userName) {
      console.log("üéØ showTypingIndicator called with:", userName);
      const indicator = document.getElementById("typing-indicator");
      const userNameEl = document.getElementById("typing-user-name");

      if (indicator && userNameEl) {
        console.log("‚úÖ Typing indicator elements found");
        userNameEl.textContent = userName;
        indicator.classList.remove("hidden");
        indicator.style.display = "block";
        console.log("‚úÖ Typing indicator shown for:", userName);

        // Auto-hide after 3 seconds of no typing
        clearTimeout(window.typingIndicatorTimeout);
        window.typingIndicatorTimeout = setTimeout(() => {
          console.log("‚è∞ Auto-hiding typing indicator");
          hideTypingIndicator();
        }, 3000);
      } else {
        console.error("‚ùå Typing indicator elements not found:", {
          indicator: !!indicator,
          userNameEl: !!userNameEl
        });
      }
    }

    function hideTypingIndicator() {
      console.log("üîá hideTypingIndicator called");
      const indicator = document.getElementById("typing-indicator");
      if (indicator) {
        indicator.classList.add("hidden");
        indicator.style.display = "none";
        console.log("‚úÖ Typing indicator hidden");
      } else {
        console.error("‚ùå Typing indicator element not found");
      }
    }

    // Debug function to test typing indicator manually
    function testTypingIndicator() {
      console.log("üß™ Testing typing indicator manually");
      showTypingIndicator("Test User");
      setTimeout(() => {
        hideTypingIndicator();
      }, 3000);
    }

    // Make test function available globally for debugging
    window.testTypingIndicator = testTypingIndicator;

    // Enhanced typing indicator check
    function checkTypingIndicator() {
      console.log("üîç Checking typing indicator elements:");
      const indicator = document.getElementById("typing-indicator");
      const userNameEl = document.getElementById("typing-user-name");

      console.log("Indicator element:", indicator);
      console.log("UserName element:", userNameEl);
      console.log("Indicator classes:", indicator?.className);
      console.log("Indicator style:", indicator?.style.cssText);
      console.log("Indicator visibility:", indicator?.hidden ? "hidden" : "visible");

      if (indicator) {
        console.log("‚úÖ Typing indicator exists");
        // Force show it for testing
        indicator.classList.remove("hidden");
        indicator.style.display = "block";
        if (userNameEl) {
          userNameEl.textContent = "Debug User";
        }
        console.log("üß™ Typing indicator forced visible for 3 seconds");
        setTimeout(() => {
          indicator.classList.add("hidden");
          indicator.style.display = "none";
          console.log("üß™ Typing indicator hidden after test");
        }, 3000);
      } else {
        console.error("‚ùå Typing indicator element not found!");
      }
    }

    // Make check function available globally
    window.checkTypingIndicator = checkTypingIndicator;

    // Enhanced toast function with different types
    function showToast(message, type = "success") {
      const toast = document.getElementById("toast-notification");
      const messageEl = document.getElementById("toast-message");

      // Update toast styling based on type
      const bgClass = type === "error" ? "bg-red-500" : "bg-green-500";
      const iconClass =
        type === "error" ? "fas fa-exclamation-circle" : "fas fa-check-circle";

      toast.className = `fixed top-4 right-4 ${bgClass} text-white px-6 py-3 rounded-lg shadow-lg z-50 transform transition-all duration-300`;

      const icon = toast.querySelector("i");
      icon.className = `${iconClass} mr-2`;

      messageEl.textContent = message;
      toast.classList.remove("hidden");

      setTimeout(() => {
        toast.classList.add("hidden");
      }, 4000);
    }

    // Therapist chat mode switching functions
    let currentChatMode = "patient"; // 'patient' or 'admin'

    function switchToPatientChat() {
      currentChatMode = "patient";

      // Update button styles
      document
        .getElementById("patient-chat-btn")
        .classList.remove("btn-secondary");
      document.getElementById("patient-chat-btn").classList.add("btn-primary");
      document.getElementById("admin-chat-btn").classList.remove("btn-primary");
      document.getElementById("admin-chat-btn").classList.add("btn-secondary");

      // Update page title and description
      document.querySelector("h1").innerHTML = "üí¨ Patient Conversations";
      document.querySelector(".text-xl").textContent =
        "Chat with your patients and manage your practice conversations";

      // Reload conversations for patient chat mode
      loadConversationsForMode("patient");

      showToast("Switched to Patient Chat Mode");
    }

    function switchToAdminChat() {
      currentChatMode = "admin";

      // Update button styles
      document
        .getElementById("admin-chat-btn")
        .classList.remove("btn-secondary");
      document.getElementById("admin-chat-btn").classList.add("btn-primary");
      document
        .getElementById("patient-chat-btn")
        .classList.remove("btn-primary");
      document
        .getElementById("patient-chat-btn")
        .classList.add("btn-secondary");

      // Update page title and description
      document.querySelector("h1").innerHTML = "üí¨ Admin Support";
      document.querySelector(".text-xl").textContent =
        "Contact admin support for assistance with your therapist account and practice";

      // Load admin conversations
      loadConversationsForMode("admin");

      showToast("Switched to Admin Chat Mode");
    }

    // Load conversations based on mode
    async function loadConversationsForMode(mode) {
      try {
        let endpoint;
        if (mode === "admin") {
          endpoint = "/therapist/api/admin-conversations";
        } else {
          endpoint = "/appointments/chat/conversations";
        }

        const response = await fetch(endpoint, {
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
          },
        });

        const data = await response.json();

        if (data.success) {
          conversations = data.conversations || [];
          displayConversationsForMode(mode);
        } else {
          console.error("Failed to load conversations:", data.error);
          showNoConversations();
        }
      } catch (error) {
        console.error("Error loading conversations:", error);
        showNoConversations();
      }
    }

    // Display conversations with mode-specific styling
    function displayConversationsForMode(mode) {
      const container = document.getElementById("conversations-list");
      const noConversations = document.getElementById("no-conversations");

      if (!conversations || conversations.length === 0) {
        container.innerHTML = "";
        noConversations.classList.remove("hidden");
        return;
      }

      noConversations.classList.add("hidden");

      container.innerHTML = conversations
        .map((conversation) => {
          const isAdmin =
            mode === "admin" || conversation.conversation_type === "admin";

          // Determine other user based on conversation type and current user role
          let otherUser;
          if (isAdmin) {
            otherUser = {
              name: "Admin Support",
              image: null,
              role: "admin",
              specialty: "CalmTunes Admin Team",
            };
          } else {
            // Regular patient-therapist conversation
            if (userRole === "patient") {
              // Patient viewing - show therapist info
              otherUser = {
                name: conversation.therapist_name || "Therapist",
                image: conversation.therapist_image,
                role: "therapist",
                specialty: conversation.specialty || "General Practice",
              };
            } else {
              // Therapist viewing - show patient info
              otherUser = {
                name: conversation.patient_name || "Patient",
                image: conversation.patient_image,
                role: "patient",
                specialty: "Patient",
              };
            }
          }

          const imageUrl =
            otherUser.image && !otherUser.image.startsWith("http")
              ? `/uploads/${otherUser.image}`
              : otherUser.image;

          const lastMessageTime = conversation.last_message_time
            ? formatMessageTime(conversation.last_message_time)
            : formatMessageTime(conversation.created_at);

          const unreadCount = parseInt(conversation.unread_count) || 0;

          // Admin conversation badge
          const adminBadge = isAdmin
            ? '<span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full ml-2"><i class="fas fa-headset mr-1"></i>Support</span>'
            : "";

          return `
      <div class="p-6 hover:bg-gray-50 cursor-pointer transition-colors border-l-4 ${
        isAdmin ? "border-blue-500 bg-blue-50/30" : "border-transparent"
      }"
           onclick="openConversation('${conversation.id}')">
        <div class="flex items-center justify-between">
          <div class="flex items-center flex-1">
            ${
              imageUrl
                ? `<img src="${imageUrl}" alt="${otherUser.name}" class="w-12 h-12 rounded-full object-cover mr-4">`
                : `<div class="w-12 h-12 bg-gradient-to-br ${
                    isAdmin
                      ? "from-blue-500 to-purple-600"
                      : "from-blue-400 to-purple-500"
                  } rounded-full flex items-center justify-center mr-4">
                ${
                  isAdmin
                    ? '<i class="fas fa-headset text-white"></i>'
                    : `<span class="text-white font-semibold">${otherUser.name
                        .charAt(0)
                        .toUpperCase()}</span>`
                }
              </div>`
            }
            <div class="flex-1 min-w-0">
              <div class="flex items-center justify-between">
                <div class="flex items-center">
                  <h3 class="font-semibold text-textMain truncate">${escapeHtml(
                    otherUser.name
                  )}</h3>
                  ${adminBadge}
                </div>
                <div class="flex items-center space-x-2 ml-2">
                  ${
                    unreadCount > 0
                      ? `<span class="bg-red-500 text-white text-xs rounded-full px-2 py-1 min-w-[20px] text-center">
                      ${unreadCount > 99 ? "99+" : unreadCount}
                    </span>`
                      : ""
                  }
                  <span class="text-sm text-gray-500">${lastMessageTime}</span>
                </div>
              </div>
              ${
                otherUser.specialty
                  ? `<p class="text-sm ${
                      isAdmin ? "text-blue-600" : "text-gray-500"
                    } mb-1">${escapeHtml(otherUser.specialty)}</p>`
                  : ""
              }
              <p class="text-gray-600 truncate">
                ${conversation.last_message || "No messages yet"}
              </p>
            </div>
          </div>
          <div class="ml-4">
            <i class="fas fa-chevron-right text-gray-400"></i>
          </div>
        </div>
      </div>
    `;
        })
        .join("");
    }

    // Enhanced Video/Audio Call Functions with Better Error Handling
    let localStream = null;
    let peerConnection = null;
    let currentCall = null; // 'video' or 'audio'
    let isCallActive = false;
    let callStartTime = null;
    let isInitiator = false;
    let incomingCallData = null;
    let pendingIceCandidates = []; // Store ICE candidates that arrive before peer connection is ready

    // WebRTC configuration with multiple STUN servers for better connectivity
    const rtcConfiguration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ]
    };

    // Function to log call events in chat
    async function logCallEvent(eventType) {
      if (!currentConversationId) {
        console.log('No conversation ID for call logging');
        return;
      }

      try {
        let message = '';
        const timestamp = new Date().toLocaleString();

        switch (eventType) {
          case 'video_call_started':
            message = `üìπ Video call started at ${timestamp}`;
            callStartTime = new Date();
            break;
          case 'audio_call_started':
            message = `üìû Phone call started at ${timestamp}`;
            callStartTime = new Date();
            break;
          case 'call_connected':
            message = `‚úÖ Call connected at ${timestamp}`;
            break;
          case 'call_ended':
            if (callStartTime) {
              const duration = Math.round((new Date() - callStartTime) / 1000);
              const minutes = Math.floor(duration / 60);
              const seconds = duration % 60;
              const durationStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
              message = `üìû Call ended (Duration: ${durationStr})`;
            } else {
              message = `üìû Call ended at ${timestamp}`;
            }
            break;
          default:
            return;
        }

        let endpoint;
        if (userRole === "therapist") {
          endpoint = `/therapist/api/conversations/${currentConversationId}/messages`;
        } else {
          endpoint = `/appointments/chat/${currentConversationId}/send`;
        }

        const response = await fetch(endpoint, {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content: message }),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            const newMessage = {
              id: data.message?.id || Date.now(),
              conversation_id: currentConversationId,
              sender_id: currentUserId,
              content: message,
              created_at: new Date().toISOString(),
              sender_role: userRole,
              sender_name: "<%= user.name %>",
            };

            messages.push(newMessage);
            displayMessages();

            if (socket && socket.connected) {
              socket.emit("new_message", {
                conversationId: currentConversationId,
                message: newMessage,
              });
            }

            console.log(`‚úÖ Call event logged: ${eventType}`);
          }
        }
      } catch (error) {
        console.error('‚ùå Error logging call event:', error);
      }
    }

    async function startVideoCall() {
      console.log('üìπ Starting video call...');

      if (!currentConversationId) {
        showToast('Please select a conversation first', 'error');
        return;
      }

      if (!socket || !socket.connected) {
        showToast('Not connected to server. Please refresh the page.', 'error');
        return;
      }

      if (isCallActive) {
        showToast('A call is already active. Please end the current call first.', 'error');
        return;
      }

      try {
        // Request camera and microphone permissions
        console.log('üìπ Requesting media permissions...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        console.log('‚úÖ Media permissions granted');

        currentCall = 'video';
        isInitiator = true;
        isCallActive = true;

        // Initialize peer connection
        await initializePeerConnection();

        // Add local stream to peer connection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          console.log('‚úÖ Added track to peer connection:', track.kind);
        });

        // Create offer
        console.log('üìπ Creating WebRTC offer...');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        console.log('‚úÖ Local description set');

        // Send offer FIRST and store it immediately
        console.log('üìπ Sending WebRTC offer...');
        socket.emit('webrtc_offer', {
          conversationId: currentConversationId,
          offer: offer,
          callType: 'video'
        });

        // Store offer locally for immediate availability
        window.pendingOffer = {
          offer: offer,
          callType: 'video',
          conversationId: currentConversationId
        };
        console.log('üíæ Offer stored locally for immediate availability');

        // Small delay to ensure offer is processed before incoming_call notification
        setTimeout(() => {
          console.log('üì≤ Sending incoming_call notification...');
          socket.emit('incoming_call', {
            conversationId: currentConversationId,
            callType: 'video',
            fromUser: '<%= user.name %>',
            fromUserId: currentUserId
          });
        }, 100);
        console.log('‚úÖ Call signals sent to server');

        // Show call interface
        showCallInterface('video');

        // Set local video with proper muting
        const localVideo = document.getElementById('local-video');
        if (localVideo) {
          localVideo.srcObject = localStream;
          localVideo.muted = true; // Always mute local video to prevent echo
          console.log('‚úÖ Local video stream set and muted');
        }

        // Set up caller status monitoring
        window.callerStatusInterval = setInterval(() => {
          if (peerConnection) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üîç Caller connection state check:', {
                connectionState: peerConnection.connectionState,
                iceConnectionState: peerConnection.iceConnectionState,
                signalingState: peerConnection.signalingState
              });
            }

            const statusEl = document.getElementById('call-status');
            if (peerConnection.connectionState === 'connected') {
              if (statusEl) {
                statusEl.textContent = 'Connected';
              }
              clearInterval(window.callerStatusInterval);
              window.callerStatusInterval = null;
              showToast('‚úÖ Video call connected!');
            } else if (peerConnection.connectionState === 'failed') {
              if (statusEl) {
                statusEl.textContent = 'Connection Failed';
              }
              clearInterval(window.callerStatusInterval);
              window.callerStatusInterval = null;
              showToast('‚ùå Video call connection failed', 'error');
            }
          }
        }, 500);

        // Log call start in chat
        await logCallEvent('video_call_started');

        showToast('üìπ Video call started. Waiting for other user to answer...');

      } catch (error) {
        console.error('‚ùå Error starting video call:', error);
        showToast('Failed to start video call: ' + error.message, 'error');
        endCall();
      }
    }

    async function startPhoneCall() {
      console.log('üìû Starting phone call...');

      if (!currentConversationId) {
        showToast('Please select a conversation first', 'error');
        return;
      }

      if (!socket || !socket.connected) {
        showToast('Not connected to server. Please refresh the page.', 'error');
        return;
      }

      if (isCallActive) {
        showToast('A call is already active. Please end the current call first.', 'error');
        return;
      }

      try {
        // Request microphone permission only
        console.log('üìû Requesting audio permissions...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: true
        });
        console.log('‚úÖ Audio permissions granted');

        currentCall = 'audio';
        isInitiator = true;
        isCallActive = true;

        // Initialize peer connection
        await initializePeerConnection();

        // Add local stream to peer connection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          console.log('‚úÖ Added audio track to peer connection');
        });

        // Create offer
        console.log('üìû Creating WebRTC offer...');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        console.log('‚úÖ Local description set');

        // Send offer FIRST and store it immediately
        console.log('üìû Sending WebRTC offer...');
        socket.emit('webrtc_offer', {
          conversationId: currentConversationId,
          offer: offer,
          callType: 'audio'
        });

        // Store offer locally for immediate availability
        window.pendingOffer = {
          offer: offer,
          callType: 'audio',
          conversationId: currentConversationId
        };
        console.log('üíæ Offer stored locally for immediate availability');

        // Small delay to ensure offer is processed before incoming_call notification
        setTimeout(() => {
          console.log('üì≤ Sending incoming_call notification...');
          socket.emit('incoming_call', {
            conversationId: currentConversationId,
            callType: 'audio',
            fromUser: '<%= user.name %>',
            fromUserId: currentUserId
          });
        }, 100);
        console.log('‚úÖ Call signals sent to server');

        // Show call interface
        showCallInterface('audio');

        // Set up caller status monitoring for audio calls
        window.callerStatusInterval = setInterval(() => {
          if (peerConnection) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üîç Caller audio connection state check:', {
                connectionState: peerConnection.connectionState,
                iceConnectionState: peerConnection.iceConnectionState,
                signalingState: peerConnection.signalingState
              });
            }

            const statusEl = document.getElementById('call-status');
            if (peerConnection.connectionState === 'connected') {
              if (statusEl) {
                statusEl.textContent = 'Connected';
              }
              clearInterval(window.callerStatusInterval);
              window.callerStatusInterval = null;
              showToast('‚úÖ Phone call connected!');
            } else if (peerConnection.connectionState === 'failed') {
              if (statusEl) {
                statusEl.textContent = 'Connection Failed';
              }
              clearInterval(window.callerStatusInterval);
              window.callerStatusInterval = null;
              showToast('‚ùå Phone call connection failed', 'error');
            }
          }
        }, 500);

        // Log call start in chat
        await logCallEvent('audio_call_started');

        showToast('üìû Phone call started. Waiting for other user to answer...');

      } catch (error) {
        console.error('‚ùå Error starting phone call:', error);
        showToast('Failed to start phone call: ' + error.message, 'error');
        endCall();
      }
    }

    async function initializePeerConnection() {
      try {
        console.log('üîß Initializing peer connection...');

        if (peerConnection) {
          console.log('‚ö†Ô∏è Closing existing peer connection');
          peerConnection.close();
        }

        peerConnection = new RTCPeerConnection(rtcConfiguration);

        if (!peerConnection) {
          throw new Error('Failed to create peer connection');
        }

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event && event.candidate) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üì° New ICE candidate:', event.candidate.candidate);
            }
            // Send ICE candidate to other user via socket
            if (socket && socket.connected) {
              socket.emit('webrtc_ice_candidate', {
                conversationId: currentConversationId,
                candidate: event.candidate
              });
            }
          } else {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üì° ICE candidate gathering complete');
            }
          }
        };

        // Handle remote stream
        peerConnection.ontrack = (event) => {
          console.log('üé• Received remote track:', event.track.kind, 'for call type:', currentCall);

          if (event && event.streams && event.streams[0]) {
            console.log('‚úÖ Setting remote stream for', currentCall, 'call');

            const remoteVideo = document.getElementById('remote-video');
            const remoteAudio = document.getElementById('remote-audio');

            if (currentCall === 'video' && remoteVideo) {
              console.log('üìπ Setting remote video stream');
              remoteVideo.srcObject = event.streams[0];
              console.log('‚úÖ Remote video stream set successfully');
            } else if (currentCall === 'audio' && remoteAudio) {
              console.log('üéµ Setting remote audio stream');
              remoteAudio.srcObject = event.streams[0];
              console.log('‚úÖ Remote audio stream set successfully');
            } else {
              console.warn('‚ö†Ô∏è No appropriate remote element found for call type:', currentCall);
            }
          } else {
            console.warn('‚ö†Ô∏è No remote stream received in ontrack event');
          }
        };

        // Handle ICE connection state changes
        peerConnection.oniceconnectionstatechange = () => {
          if (peerConnection) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('‚ùÑÔ∏è ICE connection state:', peerConnection.iceConnectionState);
            }
          }
        };

        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          if (peerConnection) {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üîó Connection state:', peerConnection.connectionState);
            }
            if (peerConnection.connectionState === 'connected') {
              showToast(`‚úÖ ${currentCall === 'video' ? 'Video' : 'Phone'} call connected!`);
              logCallEvent('call_connected');
            } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.error('‚ùå Connection failed or disconnected');
              }
              endCall();
              showToast('Call disconnected', 'error');
            }
          }
        };

        console.log('‚úÖ Peer connection initialized successfully');
      } catch (error) {
        console.error('‚ùå Error initializing peer connection:', error);
        showToast('Failed to initialize call: ' + error.message, 'error');
        endCall();
      }
    }

    function showCallInterface(type) {
      console.log(`üñºÔ∏è Showing ${type} call interface for ${isInitiator ? 'caller' : 'receiver'}`);

      // Create call interface modal
      const existingModal = document.getElementById('call-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Debug current call state
      console.log('üîç Call interface debug info:', {
        currentCall: type,
        isInitiator,
        isCallActive,
        hasLocalStream: !!localStream,
        hasPeerConnection: !!peerConnection
      });

      const modal = document.createElement('div');
      modal.id = 'call-modal';
      modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white rounded-lg max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden">
          <div class="p-4 border-b border-gray-200 flex justify-between items-center">
            <h3 class="text-lg font-semibold">${type === 'video' ? 'üìπ Video' : 'üìû Phone'} Call</h3>
            <button onclick="endCall()" class="text-red-500 hover:text-red-700">
              <i class="fas fa-times text-xl"></i>
            </button>
          </div>
          <div class="p-4">
            ${type === 'video' ? `
              <div class="relative bg-black rounded-lg" style="height: 480px;">
                <video id="remote-video" autoplay playsinline class="w-full h-full object-cover rounded-lg" style="background: #1f2937;"></video>
                <video id="local-video" autoplay playsinline muted class="absolute bottom-4 right-4 w-32 h-24 bg-gray-800 rounded-lg border-2 border-white shadow-lg object-cover" style="background: #374151;"></video>
                <div class="absolute top-4 left-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm">
                  <i class="fas fa-circle text-red-500 animate-pulse mr-2"></i>
                  <span id="call-status">Connecting...</span>
                </div>
                <div class="absolute bottom-4 left-4 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-xs">
                  <span id="connection-info">Waiting for connection...</span>
                </div>
              </div>
            ` : `
              <div class="text-center py-12">
                <div class="mb-6">
                  <div class="inline-block p-8 bg-green-100 rounded-full">
                    <i class="fas fa-phone-volume text-6xl text-green-500"></i>
                  </div>
                </div>
                <p class="text-2xl font-medium mb-2">${otherUser?.name || 'User'}</p>
                <p class="text-lg text-gray-600" id="call-status">Connecting...</p>
                <audio id="remote-audio" autoplay></audio>
              </div>
            `}
            <div class="flex justify-center gap-4 mt-6">
              <button onclick="toggleMute()" id="mute-btn" class="p-4 rounded-full bg-gray-600 text-white hover:bg-gray-700 transition-colors">
                <i class="fas fa-microphone text-xl"></i>
              </button>
              ${type === 'video' ? `
                <button onclick="toggleVideo()" id="video-btn" class="p-4 rounded-full bg-gray-600 text-white hover:bg-gray-700 transition-colors">
                  <i class="fas fa-video text-xl"></i>
                </button>
              ` : ''}
              <button onclick="endCall()" class="p-4 rounded-full bg-red-500 text-white hover:bg-red-600 transition-colors">
                <i class="fas fa-phone-slash text-xl"></i>
              </button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
      document.body.style.overflow = 'hidden';

      // Enhanced video element setup for receiver
      if (!isInitiator) {
        console.log('üìπ Setting up video elements for receiver...');

        // Ensure video elements are ready
        setTimeout(() => {
          const remoteVideo = document.getElementById('remote-video');
          const localVideo = document.getElementById('local-video');

          if (remoteVideo) {
            console.log('üì∫ Remote video element found, waiting for stream...');
            remoteVideo.onloadedmetadata = () => {
              console.log('‚úÖ Remote video metadata loaded');
            };
            remoteVideo.onplaying = () => {
              console.log('üé¨ Remote video started playing');
            };
          }

          if (localVideo) {
            console.log('üìπ Local video element found, waiting for stream...');
            localVideo.onloadedmetadata = () => {
              console.log('‚úÖ Local video metadata loaded');
            };
            localVideo.onplaying = () => {
              console.log('üé¨ Local video started playing');
            };
          }

          // Check video elements after a delay
          setTimeout(checkVideoElements, 1000);
        }, 500);
      }

      console.log('‚úÖ Call interface displayed');
    }

    // Debug function to check video elements
    function checkVideoElements() {
      console.log('üîç Checking video elements...');

      const remoteVideo = document.getElementById('remote-video');
      const localVideo = document.getElementById('local-video');
      const remoteAudio = document.getElementById('remote-audio');

      console.log('üìπ Video elements status:', {
        remoteVideo: {
          exists: !!remoteVideo,
          srcObject: !!remoteVideo?.srcObject,
          muted: remoteVideo?.muted,
          volume: remoteVideo?.volume,
          readyState: remoteVideo?.readyState
        },
        localVideo: {
          exists: !!localVideo,
          srcObject: !!localVideo?.srcObject,
          muted: localVideo?.muted,
          volume: localVideo?.volume,
          readyState: localVideo?.readyState
        },
        remoteAudio: {
          exists: !!remoteAudio,
          srcObject: !!remoteAudio?.srcObject,
          muted: remoteAudio?.muted,
          volume: remoteAudio?.volume
        }
      });

      // Fix any issues found
      if (remoteVideo && !remoteVideo.srcObject) {
        console.warn('‚ö†Ô∏è Remote video has no srcObject');
      }
      if (localVideo && !localVideo.muted) {
        console.warn('‚ö†Ô∏è Local video is not muted - fixing...');
        localVideo.muted = true;
      }
    }

    function showIncomingCallModal(data) {
      console.log('üì≤ Showing incoming call modal:', data);

      // Hide any existing incoming call modal first
      hideIncomingCallModal();

      const modal = document.getElementById('incoming-call-modal');
      const callerName = document.getElementById('incoming-caller-name');
      const callType = document.getElementById('incoming-call-type');
      const avatar = document.getElementById('incoming-call-avatar');

      if (modal && callerName && callType && avatar) {
        callerName.textContent = data.fromUser || 'Unknown Caller';
        callType.textContent = data.callType === 'video' ? 'üìπ Video Call' : 'üìû Phone Call';

        // Update avatar
        if (data.fromUser) {
          const firstLetter = data.fromUser.charAt(0).toUpperCase();
          avatar.innerHTML = `<span class="text-white font-semibold text-2xl">${firstLetter}</span>`;
        }

        // Store incoming call data
        incomingCallData = data;

        // Ensure modal is visible - try multiple methods
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        modal.style.display = 'flex !important';
        modal.style.zIndex = '9999';

        // Force visibility with direct style override
        modal.setAttribute('style', `
          display: flex !important;
          position: fixed !important;
          top: 0 !important;
          left: 0 !important;
          width: 100vw !important;
          height: 100vh !important;
          background-color: rgba(0, 0, 0, 0.5) !important;
          align-items: center !important;
          justify-content: center !important;
          z-index: 9999 !important;
        `);

        console.log('‚úÖ Incoming call modal shown and styled');

        // Play ringtone (optional)
        try {
          const ringtone = new Audio('/sounds/ringtone.mp3');
          ringtone.loop = true;
          ringtone.play().catch(e => console.log('Could not play ringtone:', e));
          modal.dataset.ringtone = 'playing';
        } catch (e) {
          console.log('Ringtone not available');
        }

        // Auto-decline after 30 seconds
        const timeoutId = setTimeout(() => {
          const modalElement = document.getElementById('incoming-call-modal');
          if (modalElement && modalElement.classList.contains('flex')) {
            console.log('‚è∞ Call timeout - auto declining');
            declineCall();
          }
        }, 30000);

        modal.dataset.timeoutId = timeoutId;
      } else {
        console.error('‚ùå Incoming call modal elements not found:', {
          modal: !!modal,
          callerName: !!callerName,
          callType: !!callType,
          avatar: !!avatar
        });
      }
    }

    function hideIncomingCallModal() {
      console.log('üîá Hiding incoming call modal');
      const modal = document.getElementById('incoming-call-modal');
      if (modal) {
        // Multiple methods to ensure modal is hidden
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        modal.style.display = 'none !important';
        modal.style.zIndex = '-1';

        // Remove any forced styles
        modal.removeAttribute('style');

        // Stop ringtone
        if (modal.dataset.ringtone === 'playing') {
          modal.dataset.ringtone = '';
        }

        // Clear timeout
        if (modal.dataset.timeoutId) {
          clearTimeout(parseInt(modal.dataset.timeoutId));
          modal.dataset.timeoutId = '';
        }

        console.log('‚úÖ Incoming call modal hidden completely');
      } else {
        console.log('‚ö†Ô∏è Incoming call modal not found');
      }
    }

    async function answerCall() {
      console.log('‚úÖ Answering call...');
      if (!incomingCallData) {
        showToast('No incoming call to answer', 'error');
        return;
      }

      if (isCallActive) {
        showToast('A call is already active. Please end the current call first.', 'error');
        hideIncomingCallModal();
        return;
      }

      try {
        console.log('üìû Hiding incoming call modal before answering...');
        hideIncomingCallModal();

        // Request media permissions based on call type
        const constraints = incomingCallData.callType === 'video'
          ? { video: true, audio: true }
          : { video: false, audio: true };

        console.log('üé§ Requesting media permissions:', constraints);
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('‚úÖ Media permissions granted');

        currentCall = incomingCallData.callType;
        isInitiator = false;
        isCallActive = true;

        // Initialize peer connection
        await initializePeerConnection();

        // Add local stream to peer connection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          console.log('‚úÖ Added track:', track.kind);
        });

        // CRITICAL FIX: Process the pending offer and create answer
        console.log('üîç Looking for offer in multiple locations...');
        console.log('üìã window.pendingOffer:', window.pendingOffer);
        console.log('üìã incomingCallData:', incomingCallData);

        let offerData = null;

        // Try multiple sources for the offer
        if (window.pendingOffer && window.pendingOffer.offer) {
          offerData = window.pendingOffer;
          console.log('‚úÖ Found offer in window.pendingOffer');
        } else if (incomingCallData && incomingCallData.offer) {
          offerData = incomingCallData;
          console.log('‚úÖ Found offer in incomingCallData');
        }

        if (offerData && offerData.offer) {
          console.log('üîß Processing WebRTC offer...');

          try {
            // Wait for peer connection to be in the right state
            let retries = 0;
            const maxRetries = 10;

            while (retries < maxRetries && peerConnection.signalingState !== 'stable') {
              console.log(`‚è≥ Waiting for stable signaling state... (attempt ${retries + 1}/${maxRetries})`);
              await new Promise(resolve => setTimeout(resolve, 200));
              retries++;
            }

            if (peerConnection.signalingState !== 'stable') {
              throw new Error(`Peer connection not in stable state after ${maxRetries} attempts. Current state: ${peerConnection.signalingState}`);
            }

            // Set remote description from the offer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
            console.log('‚úÖ Remote description set from offer');

            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('‚úÖ Answer created and local description set');

            // Send answer back to caller
            if (socket && socket.connected) {
              socket.emit('webrtc_answer', {
                conversationId: currentConversationId,
                answer: answer
              });
              console.log('‚úÖ Answer sent to caller');
            }

            // Clear pending offer
            window.pendingOffer = null;

            // Process any pending ICE candidates
            if (window.pendingIceCandidates && window.pendingIceCandidates.length > 0) {
              console.log(`üì° Processing ${window.pendingIceCandidates.length} pending ICE candidates`);
              for (const candidate of window.pendingIceCandidates) {
                try {
                  await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                  console.log('‚úÖ Added pending ICE candidate');
                } catch (e) {
                  console.error('‚ùå Error adding pending ICE candidate:', e);
                }
              }
              window.pendingIceCandidates = [];
            }

          } catch (error) {
            console.error('‚ùå Error processing offer:', error);
            throw error;
          }
        } else {
          console.warn('‚ö†Ô∏è No offer found - starting timeout polling...');

          // Start polling for offer with timeout
          const offerTimeout = 5000; // 5 seconds
          const pollInterval = 200; // Check every 200ms
          const startTime = Date.now();

          while (Date.now() - startTime < offerTimeout) {
            console.log('üîÑ Polling for offer...');

            // Check again for offer
            if (window.pendingOffer && window.pendingOffer.offer) {
              offerData = window.pendingOffer;
              console.log('‚úÖ Offer found during polling!');
              break;
            }

            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          if (offerData && offerData.offer) {
            console.log('üîß Processing offer found during polling...');
            try {
              await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
              const answer = await peerConnection.createAnswer();
              await peerConnection.setLocalDescription(answer);

              if (socket && socket.connected) {
                socket.emit('webrtc_answer', {
                  conversationId: currentConversationId,
                  answer: answer
                });
              }

              window.pendingOffer = null;
              console.log('‚úÖ Answer sent after polling');
            } catch (error) {
              console.error('‚ùå Error processing offer after polling:', error);
              throw error;
            }
          } else {
            throw new Error(`Offer not received within ${offerTimeout}ms timeout`);
          }
        }

        // Show call interface
        showCallInterface(currentCall);

        // Set local video if video call - with enhanced setup
        if (currentCall === 'video') {
          const localVideo = document.getElementById('local-video');
          if (localVideo) {
            localVideo.srcObject = localStream;
            localVideo.muted = true; // Mute local video to prevent echo
            localVideo.volume = 0; // Ensure no audio from local video
            console.log('‚úÖ Local video stream set and muted for receiver');

            // Force video to play
            localVideo.play().catch(e => {
              console.warn('‚ö†Ô∏è Could not auto-play local video:', e);
            });
          } else {
            console.error('‚ùå Local video element not found in call interface');
          }
        }

        // Update call status with better feedback
        const statusEl = document.getElementById('call-status');
        if (statusEl) {
          statusEl.textContent = 'Connecting...';
          console.log('üìä Call status updated to: Connecting...');
        }

        // Set up status monitoring with enhanced feedback
        window.statusCheckInterval = setInterval(() => {
          if (peerConnection) {
            const connectionInfo = document.getElementById('connection-info');
            const remoteVideo = document.getElementById('remote-video');

            console.log('üîç Connection state check:', {
              connectionState: peerConnection.connectionState,
              iceConnectionState: peerConnection.iceConnectionState,
              signalingState: peerConnection.signalingState,
              remoteVideoStream: !!remoteVideo?.srcObject
            });

            // Update connection info display
            if (connectionInfo) {
              if (peerConnection.connectionState === 'connecting') {
                connectionInfo.textContent = 'Establishing connection...';
              } else if (peerConnection.connectionState === 'connected') {
                const streamInfo = remoteVideo?.srcObject ? 'Stream received' : 'Connecting stream...';
                connectionInfo.textContent = `Connected - ${streamInfo}`;
              } else if (peerConnection.connectionState === 'failed') {
                connectionInfo.textContent = 'Connection failed';
              } else {
                connectionInfo.textContent = `State: ${peerConnection.connectionState}`;
              }
            }

            if (peerConnection.connectionState === 'connected') {
              if (statusEl) {
                statusEl.textContent = 'Connected';
              }

              // Check if we have remote stream
              if (remoteVideo && remoteVideo.srcObject) {
                console.log('‚úÖ Both connection and remote stream established');

                // Clear remote stream timeout
                if (window.remoteStreamTimeout) {
                  clearTimeout(window.remoteStreamTimeout);
                  window.remoteStreamTimeout = null;
                }

                clearInterval(window.statusCheckInterval);
                window.statusCheckInterval = null;
                showToast('‚úÖ Call connected successfully!');
              } else {
                console.log('‚ö†Ô∏è Connection established but no remote stream yet');
                if (connectionInfo) {
                  connectionInfo.textContent = 'Connected - Waiting for video...';
                }
              }
            } else if (peerConnection.connectionState === 'failed') {
              if (statusEl) {
                statusEl.textContent = 'Connection Failed';
              }
              if (connectionInfo) {
                connectionInfo.textContent = 'Connection failed - check network';
              }
              clearInterval(window.statusCheckInterval);
              window.statusCheckInterval = null;
              showToast('‚ùå Call connection failed', 'error');
            }
          }
        }, 500);

        // Log call answer in chat
        await logCallEvent(`${currentCall}_call_started`);

        showToast(`‚úÖ Answering ${currentCall === 'video' ? 'video' : 'phone'} call...`);

        // Set up fallback timeout for remote stream
        if (currentCall === 'video') {
          window.remoteStreamTimeout = setTimeout(() => {
            const remoteVideo = document.getElementById('remote-video');
            if (remoteVideo && !remoteVideo.srcObject) {
              console.warn('‚ö†Ô∏è Remote video stream did not arrive within 10 seconds');
              const connectionInfo = document.getElementById('connection-info');
              if (connectionInfo) {
                connectionInfo.textContent = 'No video stream received - check caller camera';
              }
              showToast('‚ö†Ô∏è No video stream from caller - they may need to enable camera', 'error');
            }
          }, 10000);
        }

      } catch (error) {
        console.error('‚ùå Error answering call:', error);
        showToast('Failed to answer call: ' + error.message, 'error');
        declineCall();
      }
    }

    function declineCall() {
      console.log('Declining call...');

      if (!incomingCallData) {
        console.log('‚ö†Ô∏è No incoming call to decline');
        return;
      }

      hideIncomingCallModal();

      // Notify caller that call was declined
      if (socket && socket.connected && incomingCallData) {
        socket.emit('call_ended', {
          conversationId: currentConversationId,
          reason: 'declined'
        });
      }

      incomingCallData = null;
      showToast('Call declined');
    }

    async function endCall() {
      console.log('üõë Ending call...');

      // Stop local media tracks
      if (localStream) {
        console.log('üîá Stopping local media tracks...');
        localStream.getTracks().forEach(track => {
          track.stop();
          console.log('‚èπÔ∏è Stopped track:', track.kind);
        });
        localStream = null;
      }

      // Close peer connection
      if (peerConnection) {
        console.log('üîå Closing peer connection...');
        peerConnection.close();
        peerConnection = null;
      }

      // Clear any existing intervals/timeouts
      if (window.callerStatusInterval) {
        clearInterval(window.callerStatusInterval);
        window.callerStatusInterval = null;
      }
      if (window.statusCheckInterval) {
        clearInterval(window.statusCheckInterval);
        window.statusCheckInterval = null;
      }
      if (window.remoteStreamTimeout) {
        clearTimeout(window.remoteStreamTimeout);
        window.remoteStreamTimeout = null;
      }

      // Reset WebRTC handlers flag to allow re-initialization if needed
      window.webRTCHandlersSetup = false;

      // Remove call modal
      const modal = document.getElementById('call-modal');
      if (modal) {
        console.log('üóëÔ∏è Removing call modal...');
        modal.remove();
      }

      // Hide incoming call modal if visible
      hideIncomingCallModal();

      // Restore body scroll
      document.body.style.overflow = '';

      // Clear all pending data
      console.log('üßπ Clearing pending call data...');
      window.pendingOffer = null;
      if (window.pendingIceCandidates) {
        window.pendingIceCandidates = [];
      }
      incomingCallData = null;

      // Notify other user that call ended
      if (socket && socket.connected && currentConversationId) {
        console.log('üì° Notifying other user call ended...');
        socket.emit('call_ended', {
          conversationId: currentConversationId,
          reason: 'ended'
        });
      }

      // Log call end in chat
      if (currentConversationId) {
        await logCallEvent('call_ended');
      }

      // Reset call state
      console.log('üîÑ Resetting call state...');
      isCallActive = false;
      currentCall = null;
      isInitiator = false;

      showToast('üìû Call ended');
      console.log('‚úÖ Call cleanup completed');
    }

    function toggleMute() {
      if (!localStream) {
        console.log('‚ö†Ô∏è No local stream available for mute toggle');
        return;
      }

      const audioTracks = localStream.getAudioTracks();
      if (audioTracks.length > 0) {
        const audioTrack = audioTracks[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          const btn = document.getElementById('mute-btn');
          const icon = btn?.querySelector('i');

          if (audioTrack.enabled) {
            btn?.classList.remove('bg-red-500');
            btn?.classList.add('bg-gray-600');
            if (icon) icon.className = 'fas fa-microphone text-xl';
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üé§ Microphone unmuted');
            }
          } else {
            btn?.classList.remove('bg-gray-600');
            btn?.classList.add('bg-red-500');
            if (icon) icon.className = 'fas fa-microphone-slash text-xl';
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üîá Microphone muted');
            }
          }
        }
      } else {
        console.log('‚ö†Ô∏è No audio tracks found in local stream');
      }
    }

    function toggleVideo() {
      if (!localStream) {
        console.log('‚ö†Ô∏è No local stream available for video toggle');
        return;
      }

      const videoTracks = localStream.getVideoTracks();
      if (videoTracks.length > 0) {
        const videoTrack = videoTracks[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          const btn = document.getElementById('video-btn');
          const icon = btn?.querySelector('i');

          if (videoTrack.enabled) {
            btn?.classList.remove('bg-red-500');
            btn?.classList.add('bg-gray-600');
            if (icon) icon.className = 'fas fa-video text-xl';
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üìπ Video enabled');
            }
          } else {
            btn?.classList.remove('bg-gray-600');
            btn?.classList.add('bg-red-500');
            if (icon) icon.className = 'fas fa-video-slash text-xl';
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
              console.log('üìπ Video disabled');
            }
          }
        }
      } else {
        console.log('‚ö†Ô∏è No video tracks found in local stream');
      }
    }


    // Initialize chat mode for therapists
    document.addEventListener("DOMContentLoaded", function () {
      // Check if we're in therapist mode and set up chat mode switching
      const userRole = "<%= user && user.role %>";
      if (userRole === "therapist") {
        // Set initial state for therapist chat mode buttons
        const patientBtn = document.getElementById("patient-chat-btn");
        const adminBtn = document.getElementById("admin-chat-btn");

        if (patientBtn && adminBtn) {
          patientBtn.classList.add("btn-primary");
          adminBtn.classList.add("btn-secondary");
        }

        // Override the loadConversations function for therapists
        const originalLoadConversations = loadConversations;
        loadConversations = function () {
          loadConversationsForMode(currentChatMode);
        };
      }
    });
  </script>
</div>
